var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},e={},n={},r=t.parcelRequire4485;null==r&&((r=function(t){if(t in e)return e[t].exports;if(t in n){var r=n[t];delete n[t];var a={id:t,exports:{}};return e[t]=a,r.call(a.exports,a,a.exports),a.exports}var i=new Error("Cannot find module '"+t+"'");throw i.code="MODULE_NOT_FOUND",i}).register=function(t,e){n[t]=e},t.parcelRequire4485=r);var a=r("ilwiq"),i=r("jiuw3"),o=r("5Rd1x"),l=r("7lx9d");a=r("ilwiq");class c extends a.DataTextureLoader{constructor(t){super(t),this.type=a.HalfFloatType}parse(t){const e=function(t,e){switch(t){case 1:console.error("THREE.RGBELoader Read Error: "+(e||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(e||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(e||""));break;default:console.error("THREE.RGBELoader: Error: "+(e||""))}return-1},n=function(t,e,n){e=e||1024;let r=t.pos,a=-1,i=0,o="",l=String.fromCharCode.apply(null,new Uint16Array(t.subarray(r,r+128)));for(;0>(a=l.indexOf("\n"))&&i<e&&r<t.byteLength;)o+=l,i+=l.length,r+=128,l+=String.fromCharCode.apply(null,new Uint16Array(t.subarray(r,r+128)));return-1<a&&(!1!==n&&(t.pos+=i+a+1),o+l.slice(0,a))},r=function(t,e,n,r){const a=t[e+3],i=Math.pow(2,a-128)/255;n[r+0]=t[e+0]*i,n[r+1]=t[e+1]*i,n[r+2]=t[e+2]*i,n[r+3]=1},i=function(t,e,n,r){const i=t[e+3],o=Math.pow(2,i-128)/255;n[r+0]=a.DataUtils.toHalfFloat(Math.min(t[e+0]*o,65504)),n[r+1]=a.DataUtils.toHalfFloat(Math.min(t[e+1]*o,65504)),n[r+2]=a.DataUtils.toHalfFloat(Math.min(t[e+2]*o,65504)),n[r+3]=a.DataUtils.toHalfFloat(1)},o=new Uint8Array(t);o.pos=0;const l=function(t){const r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*FORMAT=(\S+)\s*$/,o=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,l={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let c,s;if(t.pos>=t.byteLength||!(c=n(t)))return e(1,"no header found");if(!(s=c.match(/^#\?(\S+)/)))return e(3,"bad initial token");for(l.valid|=1,l.programtype=s[1],l.string+=c+"\n";c=n(t),!1!==c;)if(l.string+=c+"\n","#"!==c.charAt(0)){if((s=c.match(r))&&(l.gamma=parseFloat(s[1])),(s=c.match(a))&&(l.exposure=parseFloat(s[1])),(s=c.match(i))&&(l.valid|=2,l.format=s[1]),(s=c.match(o))&&(l.valid|=4,l.height=parseInt(s[1],10),l.width=parseInt(s[2],10)),2&l.valid&&4&l.valid)break}else l.comments+=c+"\n";return 2&l.valid?4&l.valid?l:e(3,"missing image size specifier"):e(3,"missing format specifier")}(o);if(-1!==l){const t=l.width,n=l.height,c=function(t,n,r){const a=n;if(a<8||a>32767||2!==t[0]||2!==t[1]||128&t[2])return new Uint8Array(t);if(a!==(t[2]<<8|t[3]))return e(3,"wrong scanline width");const i=new Uint8Array(4*n*r);if(!i.length)return e(4,"unable to allocate buffer space");let o=0,l=0;const c=4*a,s=new Uint8Array(4),d=new Uint8Array(c);let f=r;for(;f>0&&l<t.byteLength;){if(l+4>t.byteLength)return e(1);if(s[0]=t[l++],s[1]=t[l++],s[2]=t[l++],s[3]=t[l++],2!=s[0]||2!=s[1]||(s[2]<<8|s[3])!=a)return e(3,"bad rgbe scanline format");let n,r=0;for(;r<c&&l<t.byteLength;){n=t[l++];const a=n>128;if(a&&(n-=128),0===n||r+n>c)return e(3,"bad scanline data");if(a){const e=t[l++];for(let t=0;t<n;t++)d[r++]=e}else d.set(t.subarray(l,l+n),r),r+=n,l+=n}const m=a;for(let t=0;t<m;t++){let e=0;i[o]=d[t+e],e+=a,i[o+1]=d[t+e],e+=a,i[o+2]=d[t+e],e+=a,i[o+3]=d[t+e],o+=4}f--}return i}(o.subarray(o.pos),t,n);if(-1!==c){let e,o,s;switch(this.type){case a.FloatType:s=c.length/4;const t=new Float32Array(4*s);for(let e=0;e<s;e++)r(c,4*e,t,4*e);e=t,o=a.FloatType;break;case a.HalfFloatType:s=c.length/4;const n=new Uint16Array(4*s);for(let t=0;t<s;t++)i(c,4*t,n,4*t);e=n,o=a.HalfFloatType;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:t,height:n,data:e,header:l.string,gamma:l.gamma,exposure:l.exposure,type:o}}}return null}setDataType(t){return this.type=t,this}load(t,e,n,r){return super.load(t,(function(t,n){switch(t.type){case a.FloatType:case a.HalfFloatType:t.encoding=a.LinearEncoding,t.minFilter=a.LinearFilter,t.magFilter=a.LinearFilter,t.generateMipmaps=!1,t.flipY=!0}e&&e(t,n)}),n,r)}}var s=function(){var t=0,e=document.createElement("div");function n(t){return e.appendChild(t.dom),t}function r(n){for(var r=0;r<e.children.length;r++)e.children[r].style.display=r===n?"block":"none";t=n}e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",(function(n){n.preventDefault(),r(++t%e.children.length)}),!1);var a=(performance||Date).now(),i=a,o=0,l=n(new s.Panel("FPS","#0ff","#002")),c=n(new s.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var d=n(new s.Panel("MB","#f08","#201"));return r(0),{REVISION:16,dom:e,addPanel:n,showPanel:r,begin:function(){a=(performance||Date).now()},end:function(){o++;var t=(performance||Date).now();if(c.update(t-a,200),t>=i+1e3&&(l.update(1e3*o/(t-i),100),i=t,o=0,d)){var e=performance.memory;d.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){a=this.end()},domElement:e,setMode:r}};s.Panel=function(t,e,n){var r=1/0,a=0,i=Math.round,o=i(window.devicePixelRatio||1),l=80*o,c=48*o,s=3*o,d=2*o,f=3*o,m=15*o,u=74*o,p=30*o,h=document.createElement("canvas");h.width=l,h.height=c,h.style.cssText="width:80px;height:48px";var v=h.getContext("2d");return v.font="bold "+9*o+"px Helvetica,Arial,sans-serif",v.textBaseline="top",v.fillStyle=n,v.fillRect(0,0,l,c),v.fillStyle=e,v.fillText(t,s,d),v.fillRect(f,m,u,p),v.fillStyle=n,v.globalAlpha=.9,v.fillRect(f,m,u,p),{dom:h,update:function(c,g){r=Math.min(r,c),a=Math.max(a,c),v.fillStyle=n,v.globalAlpha=1,v.fillRect(0,0,l,m),v.fillStyle=e,v.fillText(i(c)+" "+t+" ("+i(r)+"-"+i(a)+")",s,d),v.drawImage(h,f+o,m,u-o,p,f,m,u-o,p),v.fillRect(f+u-o,m,o,p),v.fillStyle=n,v.globalAlpha=.9,v.fillRect(f+u-o,m,o,i((1-c/g)*p))}}};var d=s,f=r("4CEV9");let m,u,p,h,v,g,y,w,b;const x={color:"#ffffff",bounces:3,ior:2.4,aberrationStrength:.01,fastChroma:!1,animate:!0};function D(){x.animate&&(g.rotation.y+=.25*b.getDelta()),w.update(),v.update(),p.render(m,u),requestAnimationFrame(D)}!async function(){m=new a.Scene,u=new a.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,1e3),u.position.set(28,15,7),p=new a.WebGLRenderer({antialias:!1}),p.setSize(window.innerWidth,window.innerHeight),p.outputEncoding=a.sRGBEncoding,p.toneMapping=a.ACESFilmicToneMapping,document.body.appendChild(p.domElement),v=new o.OrbitControls(u,p.domElement),b=new a.Clock;const t=(new c).loadAsync("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/venice_sunset_1k.hdr"),e=(new l.GLTFLoader).loadAsync("../models/diamond.glb");let n;[h,n]=await Promise.all([t,e]),h.mapping=a.EquirectangularReflectionMapping,h.generateMipmaps=!0,h.minFilter=a.LinearMipmapLinearFilter,h.magFilter=a.LinearFilter,m.background=h;const r=new a.ShaderMaterial({uniforms:{envMap:{value:h},bvh:{value:new f.MeshBVHUniformStruct},projectionMatrixInv:{value:u.projectionMatrixInverse},viewMatrixInv:{value:u.matrixWorld},resolution:{value:new a.Vector2},bounces:{value:3},ior:{value:2.4},color:{value:new a.Color(1,1,1)},fastChroma:{value:!1},aberrationStrength:{value:.01}},vertexShader:"\n\t\t\tvarying vec3 vWorldPosition;\n\t\t\tvarying vec3 vNormal;\n\t\t\tuniform mat4 viewMatrixInv;\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldPosition = ( modelMatrix * vec4( position, 1.0 ) ).xyz;\n\t\t\t\tvNormal = ( viewMatrixInv * vec4( normalMatrix * normal, 0.0 ) ).xyz;\n\t\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position , 1.0 );\n\n\t\t\t}\n\t\t",fragmentShader:`\n\t\t\t#define RAY_OFFSET 0.001\n\n\t\t\t#include <common>\n\t\t\tprecision highp isampler2D;\n\t\t\tprecision highp usampler2D;\n\n\t\t\t${f.shaderStructs}\n\t\t\t${f.shaderIntersectFunction}\n\n\t\t\tvarying vec3 vWorldPosition;\n\t\t\tvarying vec3 vNormal;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform float bounces;\n\t\t\tuniform BVH bvh;\n\t\t\tuniform float ior;\n\t\t\tuniform vec3 color;\n\t\t\tuniform bool fastChroma;\n\t\t\tuniform mat4 projectionMatrixInv;\n\t\t\tuniform mat4 viewMatrixInv;\n\t\t\tuniform mat4 modelMatrix;\n\t\t\tuniform vec2 resolution;\n\t\t\tuniform float aberrationStrength;\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t// performs an iterative bounce lookup modeling internal reflection and returns\n\t\t\t// a final ray direction.\n\t\t\tvec3 totalInternalReflection( vec3 incomingOrigin, vec3 incomingDirection, vec3 normal, float ior, mat4 modelMatrixInverse ) {\n\n\t\t\t\tvec3 rayOrigin = incomingOrigin;\n\t\t\t\tvec3 rayDirection = incomingDirection;\n\n\t\t\t\t// refract the ray direction on the way into the diamond and adjust offset from\n\t\t\t\t// the diamond surface for raytracing\n\t\t\t\trayDirection = refract( rayDirection, normal, 1.0 / ior );\n\t\t\t\trayOrigin = vWorldPosition + rayDirection * RAY_OFFSET;\n\n\t\t\t\t// transform the ray into the local coordinates of the model\n\t\t\t\trayOrigin = ( modelMatrixInverse * vec4( rayOrigin, 1.0 ) ).xyz;\n\t\t\t\trayDirection = normalize( ( modelMatrixInverse * vec4( rayDirection, 0.0 ) ).xyz );\n\n\t\t\t\t// perform multiple ray casts\n\t\t\t\tfor( float i = 0.0; i < bounces; i ++ ) {\n\n\t\t\t\t\t// results\n\t\t\t\t\tuvec4 faceIndices = uvec4( 0u );\n\t\t\t\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\tvec3 barycoord = vec3( 0.0 );\n\t\t\t\t\tfloat side = 1.0;\n\t\t\t\t\tfloat dist = 0.0;\n\n\t\t\t\t\t// perform the raycast\n\t\t\t\t\t// the diamond is a water tight model so we assume we always hit a surface\n\t\t\t\t\tbvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n\n\t\t\t\t\t// derive the new ray origin from the hit results\n\t\t\t\t\tvec3 hitPos = rayOrigin + rayDirection * dist;\n\n\t\t\t\t\t// if we don't internally reflect then end the ray tracing and sample\n\t\t\t\t\tvec3 refractedDirection = refract( rayDirection, faceNormal, ior );\n\t\t\t\t\tbool totalInternalReflection = length( refract( rayDirection, faceNormal, ior ) ) == 0.0;\n\t\t\t\t\tif ( ! totalInternalReflection ) {\n\n\t\t\t\t\t\trayDirection = refractedDirection;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// otherwise reflect off the surface internally for another hit\n\t\t\t\t\trayDirection = reflect( rayDirection, faceNormal );\n\t\t\t\t\trayOrigin = hitPos + rayDirection * RAY_OFFSET;\n\n\t\t\t\t}\n\n\t\t\t\t// return the final ray direction in world space\n\t\t\t\treturn normalize( ( modelMatrix * vec4( rayDirection, 0.0 ) ).xyz );\n\t\t\t}\n\n\t\t\tvec4 envSample( sampler2D envMap, vec3 rayDirection ) {\n\n\t\t\t\tvec2 uvv = equirectUv( rayDirection );\n\t\t\t\treturn texture( envMap, uvv );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tmat4 modelMatrixInverse = inverse( modelMatrix );\n\t\t\t\tvec2 uv = gl_FragCoord.xy / resolution;\n\n\t\t\t\tvec3 normal = vNormal;\n\t\t\t\tvec3 rayOrigin = cameraPosition;\n\t\t\t\tvec3 rayDirection = normalize( vWorldPosition - cameraPosition );\n\n\t\t\t\tif ( aberrationStrength != 0.0 ) {\n\n\t\t\t\t\t// perform chromatic aberration lookups\n\t\t\t\t\tvec3 rayDirectionG = totalInternalReflection( rayOrigin, rayDirection, normal, max( ior, 1.0 ), modelMatrixInverse );\n\t\t\t\t\tvec3 rayDirectionR, rayDirectionB;\n\n\t\t\t\t\tif ( fastChroma ) {\n\n\t\t\t\t\t\t// fast chroma does a quick uv offset on lookup\n\t\t\t\t\t\trayDirectionR = normalize( rayDirectionG + 1.0 * vec3( aberrationStrength / 2.0 ) );\n\t\t\t\t\t\trayDirectionB = normalize( rayDirectionG - 1.0 * vec3( aberrationStrength / 2.0 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// compared to a proper ray trace of diffracted rays\n\t\t\t\t\t\tfloat iorR = max( ior * ( 1.0 - aberrationStrength ), 1.0 );\n\t\t\t\t\t\tfloat iorB = max( ior * ( 1.0 + aberrationStrength ), 1.0 );\n\t\t\t\t\t\trayDirectionR = totalInternalReflection(\n\t\t\t\t\t\t\trayOrigin, rayDirection, normal,\n\t\t\t\t\t\t\tiorR, modelMatrixInverse\n\t\t\t\t\t\t);\n\t\t\t\t\t\trayDirectionB = totalInternalReflection(\n\t\t\t\t\t\t\trayOrigin, rayDirection, normal,\n\t\t\t\t\t\t\tiorB, modelMatrixInverse\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// get the color lookup\n\t\t\t\t\tfloat r = envSample( envMap, rayDirectionR ).r;\n\t\t\t\t\tfloat g = envSample( envMap, rayDirectionG ).g;\n\t\t\t\t\tfloat b = envSample( envMap, rayDirectionB ).b;\n\t\t\t\t\tgl_FragColor.rgb = vec3( r, g, b ) * color;\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// no chromatic aberration lookups\n\t\t\t\t\trayDirection = totalInternalReflection( rayOrigin, rayDirection, normal, max( ior, 1.0 ), modelMatrixInverse );\n\t\t\t\t\tgl_FragColor.rgb = envSample( envMap, rayDirection ).rgb * color;\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t}\n\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <encodings_fragment>\n\n\t\t\t}\n\t\t`}),s=n.scene.children[0].children[0].children[0].children[0].children[0].geometry;s.scale(10,10,10);const M=new f.MeshBVH(s,{strategy:f.SAH,maxLeafTris:1});r.uniforms.bvh.value.updateFrom(M),g=new a.Mesh(s,r),m.add(g),y=new i.GUI,y.add(x,"animate"),y.addColor(x,"color").name("Color").onChange((t=>{g.material.uniforms.color.value.set(t)})),y.add(x,"bounces",1,10,1).name("Bounces").onChange((t=>{g.material.uniforms.bounces.value=t})),y.add(x,"ior",1,5,.01).name("IOR").onChange((t=>{g.material.uniforms.ior.value=t})),y.add(x,"fastChroma").onChange((t=>{g.material.uniforms.fastChroma.value=t})),y.add(x,"aberrationStrength",0,.1,1e-4).onChange((t=>{g.material.uniforms.aberrationStrength.value=t})),w=new d,w.showPanel(0),document.body.appendChild(w.dom),D(),window.addEventListener("resize",(function(){u.aspect=window.innerWidth/window.innerHeight,u.updateProjectionMatrix(),g.material.uniforms.resolution.value.set(window.innerWidth,window.innerHeight),p.setSize(window.innerWidth,window.innerHeight)}),!1)}();
//# sourceMappingURL=diamond.7afaf405.js.map
