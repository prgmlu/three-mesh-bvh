{"mappings":"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","sources":["example/utils/edgeUtils.js","example/edgeProjection.js"],"sourcesContent":["import { Vector3, Triangle, Line3, MathUtils, Plane, BufferGeometry, BufferAttribute } from 'three';\nimport { ExtendedTriangle } from '../..';\n\nconst _upVector = new Vector3( 0, 1, 0 );\nconst EPSILON = 1e-16;\n\n// Modified version of js EdgesGeometry logic to handle silhouette edges\nexport const generateEdges = ( function () {\n\n\tconst _v0 = new Vector3();\n\tconst _v1 = new Vector3();\n\tconst _normal = new Vector3();\n\tconst _triangle = new Triangle();\n\n\treturn function generateEdges( geometry, projectionDir, thresholdAngle = 1 ) {\n\n\t\tconst edges = [];\n\n\t\tconst precisionPoints = 4;\n\t\tconst precision = Math.pow( 10, precisionPoints );\n\t\tconst thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );\n\n\t\tconst indexAttr = geometry.getIndex();\n\t\tconst positionAttr = geometry.getAttribute( 'position' );\n\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\t\tconst indexArr = [ 0, 0, 0 ];\n\t\tconst vertKeys = [ 'a', 'b', 'c' ];\n\t\tconst hashes = new Array( 3 );\n\n\t\tconst edgeData = {};\n\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\t\tif ( indexAttr ) {\n\n\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t\t} else {\n\n\t\t\t\tindexArr[ 0 ] = i;\n\t\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t\t}\n\n\t\t\tconst { a, b, c } = _triangle;\n\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t\t_triangle.getNormal( _normal );\n\n\t\t\t// create hashes for the edge from the vertices\n\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t\t// skip degenerate triangles\n\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// iterate over every edge\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\tconst otherNormal = edgeData[ reverseHash ].normal;\n\t\t\t\t\tconst meetsThreshold = _normal.dot( otherNormal ) <= thresholdDot;\n\t\t\t\t\tconst projectionThreshold = Math.sign( projectionDir.dot( _normal ) ) !== Math.sign( projectionDir.dot( otherNormal ) );\n\t\t\t\t\tif ( meetsThreshold || projectionThreshold ) {\n\n\t\t\t\t\t\tconst line = new Line3();\n\t\t\t\t\t\tline.start.copy( v0 );\n\t\t\t\t\t\tline.end.copy( v1 );\n\t\t\t\t\t\tedges.push( line );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\t\tfor ( const key in edgeData ) {\n\n\t\t\tif ( edgeData[ key ] ) {\n\n\t\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t\t_v1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\t\tconst line = new Line3();\n\t\t\t\tline.start.copy( _v0 );\n\t\t\t\tline.end.copy( _v1 );\n\t\t\t\tedges.push( line );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn edges;\n\n\t};\n\n} )();\n\n// outputs the overlapping segment of a coplanar line and triangle\nexport const getOverlappingLine = ( function () {\n\n\tconst _dir0 = new Vector3();\n\tconst _dir1 = new Vector3();\n\tconst _tempDir = new Vector3();\n\tconst _orthoPlane = new Plane();\n\tconst _line0 = new Line3();\n\tconst _line1 = new Line3();\n\tconst _tempLine = new Line3();\n\n\treturn function getOverlappingLine( line, triangle, lineTarget = new Line3() ) {\n\n\t\tif ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.needsUpdate();\n\n\t\t}\n\n\t\t// if the triangle is degenerate then return no overlap\n\t\tif ( triangle.getArea() <= EPSILON ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst { points, plane } = triangle;\n\n\t\t_line0.copy( line );\n\t\t_line0.delta( _dir0 );\n\n\t\t// if the line and triangle are not coplanar then return no overlap\n\t\tconst areCoplanar = plane.normal.dot( _dir0 ) === 0.0;\n\t\tif ( ! areCoplanar ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// a plane that's orthogonal to the triangle that the line lies on\n\t\t_dir0.cross( plane.normal ).normalize();\n\t\t_orthoPlane.setFromNormalAndCoplanarPoint( _dir0, _line0.start );\n\n\t\t// find the line of intersection of the triangle along the plane if it exists\n\t\tlet intersectCount = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst p1 = points[ i ];\n\t\t\tconst p2 = points[ ( i + 1 ) % 3 ];\n\n\t\t\t_tempLine.start.copy( p1 );\n\t\t\t_tempLine.end.copy( p2 );\n\t\t\tif ( _orthoPlane.distanceToPoint( _tempLine.end ) === 0 && _orthoPlane.distanceToPoint( _tempLine.start ) === 0 ) {\n\n\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t_line1.copy( _tempLine );\n\t\t\t\tintersectCount = 2;\n\t\t\t\tbreak;\n\n\t\t\t} else if ( _orthoPlane.intersectLine( _tempLine, intersectCount === 0 ? _line1.start : _line1.end ) ) {\n\n\t\t\t\tlet p;\n\t\t\t\tif ( intersectCount === 0 ) {\n\n\t\t\t\t\tp = _line1.start;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp = _line1.end;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.distanceTo( p2 ) === 0.0 ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tintersectCount ++;\n\t\t\t\tif ( intersectCount === 2 ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( intersectCount === 2 ) {\n\n\t\t\t// find the intersect line if any\n\t\t\t_line0.delta( _dir0 ).normalize();\n\t\t\t_line1.delta( _dir1 ).normalize();\n\n\t\t\t// swap edges so they're facing in the same direction\n\t\t\tif ( _dir0.dot( _dir1 ) < 0 ) {\n\n\t\t\t\tlet tmp = _line1.start;\n\t\t\t\t_line1.start = _line1.end;\n\t\t\t\t_line1.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = _line0.start.dot( _dir0 );\n\t\t\tconst e1 = _line0.end.dot( _dir0 );\n\t\t\tconst s2 = _line1.start.dot( _dir0 );\n\t\t\tconst e2 = _line1.end.dot( _dir0 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\t_tempDir.subVectors( _line0.start, _line1.start );\n\t\t\tif ( _tempDir.dot( _dir0 ) > 0 ) {\n\n\t\t\t\tlineTarget.start.copy( _line0.start );\n\n\t\t\t} else {\n\n\t\t\t\tlineTarget.start.copy( _line1.start );\n\n\t\t\t}\n\n\t\t\t_tempDir.subVectors( _line0.end, _line1.end );\n\t\t\tif ( _tempDir.dot( _dir0 ) < 0 ) {\n\n\t\t\t\tlineTarget.end.copy( _line0.end );\n\n\t\t\t} else {\n\n\t\t\t\tlineTarget.end.copy( _line1.end );\n\n\t\t\t}\n\n\t\t\treturn lineTarget;\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n} )();\n\n// returns the the y value on the plane at the given point x, z\nexport const getPlaneYAtPoint = ( function () {\n\n\tconst testLine = new Line3();\n\treturn function getPlaneYAtPoint( plane, point, target = null ) {\n\n\t\ttestLine.start.copy( point );\n\t\ttestLine.end.copy( point );\n\n\t\ttestLine.start.y += 1e5;\n\t\ttestLine.end.y -= 1e5;\n\n\t\tplane.intersectLine( testLine, target );\n\n\t};\n\n} )();\n\n// returns whether the given line is above the given triangle plane\nexport const isLineAbovePlane = ( function () {\n\n\tconst _v0 = new Vector3();\n\tconst _v1 = new Vector3();\n\n\treturn function isLineAbovePlane( plane, line ) {\n\n\t\t_v0.lerpVectors( line.start, line.end, 0.5 );\n\t\tgetPlaneYAtPoint( plane, _v0, _v1 );\n\n\t\treturn _v1.y < _v0.y;\n\n\t};\n\n} )();\n\nexport const isYProjectedLineDegenerate = ( function () {\n\n\tconst _tempDir = new Vector3();\n\tconst _upVector = new Vector3( 0, 1, 0 );\n\treturn function isYProjectedLineDegenerate( line ) {\n\n\t\tline.delta( _tempDir ).normalize();\n\t\treturn Math.abs( _tempDir.dot( _upVector ) ) >= 1.0 - EPSILON;\n\n\t};\n\n} )();\n\n// checks whether the y-projected triangle will be degerate\nexport function isYProjectedTriangleDegenerate( tri ) {\n\n\tif ( tri.needsUpdate ) {\n\n\t\ttri.update();\n\n\t}\n\n\treturn Math.abs( tri.plane.normal.dot( _upVector ) ) <= EPSILON;\n\n}\n\n// Is the provided line exactly an edge on the triangle\nexport function isLineTriangleEdge( tri, line ) {\n\n\t// if this is the same line as on the triangle\n\tconst triPoints = tri.points;\n\tlet matches = 0;\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst { start, end } = line;\n\t\tconst tp = triPoints[ i ];\n\t\tif ( start.distanceToSquared( tp ) <= EPSILON ) {\n\n\t\t\tmatches ++;\n\n\t\t}\n\n\t\tif ( end.distanceToSquared( tp ) <= EPSILON ) {\n\n\t\t\tmatches ++;\n\n\t\t}\n\n\t}\n\n\treturn matches >= 2;\n\n}\n\n// Extracts the normalized [0, 1] distances along the given line that overlaps with the provided triangle when\n// projected along the y axis\nexport const getProjectedOverlaps = ( function () {\n\n\tconst _target = new Line3();\n\tconst _tempDir = new Vector3();\n\tconst _tempVec0 = new Vector3();\n\tconst _tempVec1 = new Vector3();\n\tconst _line = new Line3();\n\tconst _tri = new ExtendedTriangle();\n\n\treturn function getProjectedOverlaps( tri, line, overlapsTarget ) {\n\n\t\t_line.copy( line );\n\t\t_tri.copy( tri );\n\n\t\t// flatten them to a common plane\n\t\t_line.start.y = 0;\n\t\t_line.end.y = 0;\n\t\t_tri.a.y = 0;\n\t\t_tri.b.y = 0;\n\t\t_tri.c.y = 0;\n\t\t_tri.needsUpdate = true;\n\t\t_tri.update();\n\n\t\t// if the line is meaningfully long and the we have an overlapping line then extract the\n\t\t// distances along the original line to return\n\t\tif ( getOverlappingLine( _line, _tri, _target ) ) {\n\n\t\t\t_line.delta( _tempDir );\n\t\t\t_tempVec0.subVectors( _target.start, _line.start );\n\t\t\t_tempVec1.subVectors( _target.end, _line.start );\n\n\t\t\tlet d0 = _tempVec0.length() / _tempDir.length();\n\t\t\tlet d1 = _tempVec1.length() / _tempDir.length();\n\n\t\t\td0 = Math.min( Math.max( d0, 0 ), 1 );\n\t\t\td1 = Math.min( Math.max( d1, 0 ), 1 );\n\n\t\t\tif ( ! ( Math.abs( d0 - d1 ) <= EPSILON ) ) {\n\n\t\t\t\toverlapsTarget.push( new Float32Array( [ d0, d1 ] ) );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n\n// Trim the provided line to just the section below the given triangle plane\nexport const trimToBeneathTriPlane = ( function () {\n\n\tconst _lineDirection = new Vector3();\n\tconst _planeHit = new Vector3();\n\tconst _centerPoint = new Vector3();\n\tconst _planePoint = new Vector3();\n\n\treturn function trimToBeneathTriPlane( tri, line, lineTarget ) {\n\n\t\tif ( tri.needsUpdate ) {\n\n\t\t\ttri.update();\n\n\t\t}\n\n\t\tlineTarget.copy( line );\n\n\t\t// handle vertical triangles\n\t\tconst { plane } = tri;\n\t\tif ( isYProjectedTriangleDegenerate( tri ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// if the line and plane are coplanar then return that we can't trim\n\t\tline.delta( _lineDirection );\n\n\t\tconst areCoplanar = plane.normal.dot( _lineDirection ) === 0.0;\n\t\tif ( areCoplanar ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// if the line does intersect the plane then trim\n\t\tconst doesLineIntersect = plane.intersectLine( line, _planeHit );\n\t\tif ( doesLineIntersect ) {\n\n\t\t\tconst { start, end } = lineTarget;\n\n\t\t\t// test the line side with the largest segment extending beyond the plane\n\t\t\tlet testPoint;\n\t\t\tlet flipped = false;\n\t\t\tif ( start.distanceTo( _planeHit ) > end.distanceTo( _planeHit ) ) {\n\n\t\t\t\ttestPoint = start;\n\n\t\t\t} else {\n\n\t\t\t\ttestPoint = end;\n\t\t\t\tflipped = true;\n\n\t\t\t}\n\n\t\t\t// get the center point of the line segment and the plane hit\n\t\t\t_centerPoint.lerpVectors( testPoint, _planeHit, 0.5 );\n\t\t\tgetPlaneYAtPoint( tri.plane, _centerPoint, _planePoint );\n\n\t\t\t// adjust the appropriate line point align with the plane hit point\n\t\t\tif ( _planePoint.y < _centerPoint.y ) {\n\n\t\t\t\tif ( flipped ) end.copy( _planeHit );\n\t\t\t\telse start.copy( _planeHit );\n\n\t\t\t} else {\n\n\t\t\t\tif ( flipped ) start.copy( _planeHit );\n\t\t\t\telse end.copy( _planeHit );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n\n// Converts the given array of overlaps into line segments\nexport const overlapsToLines = ( function () {\n\n\tconst newLine = new Line3();\n\n\treturn function overlapsToLines( line, overlaps, target = [] ) {\n\n\t\tcompressEdgeOverlaps( overlaps );\n\n\t\tconst invOverlaps = [[ 0, 1 ]];\n\t\tfor ( let i = 0, l = overlaps.length; i < l; i ++ ) {\n\n\t\t\tconst invOverlap = invOverlaps[ i ];\n\t\t\tconst overlap = overlaps[ i ];\n\t\t\tinvOverlap[ 1 ] = overlap[ 0 ];\n\t\t\tinvOverlaps.push( new Float32Array( [ overlap[ 1 ], 1 ] ) );\n\n\t\t}\n\n\t\tfor ( let i = 0, l = invOverlaps.length; i < l; i ++ ) {\n\n\t\t\tconst { start, end } = line;\n\t\t\tnewLine.start.lerpVectors( start, end, invOverlaps[ i ][ 0 ] );\n\t\t\tnewLine.end.lerpVectors( start, end, invOverlaps[ i ][ 1 ] );\n\n\t\t\ttarget.push( new Float32Array( [\n\t\t\t\tnewLine.start.x,\n\t\t\t\tnewLine.start.y,\n\t\t\t\tnewLine.start.z,\n\n\t\t\t\tnewLine.end.x,\n\t\t\t\tnewLine.end.y,\n\t\t\t\tnewLine.end.z,\n\t\t\t] ) );\n\n\t\t}\n\n\t\treturn target;\n\n\t};\n\n} )();\n\n// converts the given list of edges to a line segments geometry\nexport function edgesToGeometry( edges, y = null ) {\n\n\tconst edgeArray = new Float32Array( edges.length * 6 );\n\tlet c = 0;\n\tfor ( let i = 0, l = edges.length; i < l; i ++ ) {\n\n\t\tconst line = edges[ i ];\n\t\tedgeArray[ c ++ ] = line[ 0 ];\n\t\tedgeArray[ c ++ ] = y === null ? line[ 1 ] : y;\n\t\tedgeArray[ c ++ ] = line[ 2 ];\n\t\tedgeArray[ c ++ ] = line[ 3 ];\n\t\tedgeArray[ c ++ ] = y === null ? line[ 4 ] : y;\n\t\tedgeArray[ c ++ ] = line[ 5 ];\n\n\t}\n\n\tconst edgeGeom = new BufferGeometry();\n\tconst edgeBuffer = new BufferAttribute( edgeArray, 3, true );\n\tedgeGeom.setAttribute( 'position', edgeBuffer );\n\treturn edgeGeom;\n\n}\n\n// compresses the given edge overlaps into a minimal set of representative objects\nexport function compressEdgeOverlaps( overlaps ) {\n\n\toverlaps.sort( ( a, b ) => {\n\n\t\treturn a[ 0 ] - b[ 0 ];\n\n\t} );\n\n\tfor ( let i = 1; i < overlaps.length; i ++ ) {\n\n\t\tconst overlap = overlaps[ i ];\n\t\tconst prevOverlap = overlaps[ i - 1 ];\n\n\t\tif ( overlap[ 0 ] <= prevOverlap[ 1 ] ) {\n\n\t\t\tprevOverlap[ 1 ] = Math.max( prevOverlap[ 1 ], overlap[ 1 ] );\n\t\t\toverlaps.splice( i, 1 );\n\t\t\ti --;\n\n\t\t}\n\n\t}\n\n}\n","import * as THREE from 'three';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { MeshBVH } from '..';\nimport {\n\tgenerateEdges,\n\tisLineAbovePlane,\n\tisYProjectedTriangleDegenerate,\n\tisLineTriangleEdge,\n\ttrimToBeneathTriPlane,\n\tedgesToGeometry,\n\toverlapsToLines,\n\tgetProjectedOverlaps,\n\tisYProjectedLineDegenerate,\n\tcompressEdgeOverlaps,\n} from './utils/edgeUtils.js';\nimport { mergeBufferGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\n\nconst params = {\n\tdisplayModel: 'color',\n\tdisplayEdges: false,\n\tdisplayProjection: true,\n\tuseBVH: true,\n\tsortEdges: true,\n\trotate: () => {\n\n\t\tgroup.quaternion.random();\n\t\tgroup.position.set( 0, 0, 0 );\n\t\tgroup.updateMatrixWorld( true );\n\n\t\tconst box = new THREE.Box3();\n\t\tbox.setFromObject( model, true );\n\t\tbox.getCenter( group.position ).multiplyScalar( - 1 );\n\t\tgroup.position.y = Math.max( 0, - box.min.y ) + 1;\n\n\t},\n\tregenerate: () => {\n\n\t\ttask = updateEdges();\n\n\t},\n};\n\nlet renderer, camera, scene, gui, controls;\nlet lines, model, projection, group, whiteModel;\nlet outputContainer;\nlet task = null;\n\ninit();\n\nasync function init() {\n\n\toutputContainer = document.getElementById( 'output' );\n\n\tconst bgColor = 0xeeeeee;\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( bgColor, 1 );\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\n\t// lights\n\tconst light = new THREE.DirectionalLight( 0xffffff, 1 );\n\tlight.position.set( 1, 2, 3 );\n\tscene.add( light );\n\tscene.add( new THREE.AmbientLight( 0xb0bec5, 0.25 ) );\n\n\t// load model\n\tgroup = new THREE.Group();\n\tscene.add( group );\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n\tconst gltf = await new GLTFLoader().setMeshoptDecoder( MeshoptDecoder ).loadAsync( 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/nasa-m2020/Perseverance.glb' );\n\tmodel = gltf.scene;\n\n\tconst whiteMaterial = new THREE.MeshStandardMaterial();\n\twhiteModel = model.clone();\n\twhiteModel.traverse( c => {\n\n\t\tif ( c.material ) {\n\n\t\t\tc.material = whiteMaterial;\n\n\t\t}\n\n\t} );\n\n\tgroup.updateMatrixWorld( true );\n\n\t// center model\n\tconst box = new THREE.Box3();\n\tbox.setFromObject( model, true );\n\tbox.getCenter( group.position ).multiplyScalar( - 1 );\n\tgroup.position.y = Math.max( 0, - box.min.y ) + 1;\n\tgroup.add( model, whiteModel );\n\n\t// generate geometry line segments\n\tlines = new THREE.Group();\n\tmodel.traverse( c => {\n\n\t\tif ( c.geometry ) {\n\n\t\t\tconst geomLines = new THREE.LineSegments( new THREE.EdgesGeometry( c.geometry, 50 ), new THREE.LineBasicMaterial( { color: 0x030303 } ) );\n\t\t\tgeomLines.position.copy( c.position );\n\t\t\tgeomLines.quaternion.copy( c.quaternion );\n\t\t\tgeomLines.scale.copy( c.scale );\n\t\t\tlines.add( geomLines );\n\n\t\t}\n\n\t} );\n\tgroup.add( lines );\n\n\t// create projection display mesh\n\tprojection = new THREE.LineSegments( new THREE.BufferGeometry(), new THREE.LineBasicMaterial( { color: 0x030303 } ) );\n\tscene.add( projection );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.01, 100 );\n\tcamera.position.setScalar( 3.5 );\n\tcamera.updateProjectionMatrix();\n\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\n\tgui = new GUI();\n\tgui.add( params, 'displayModel', [ 'none', 'color', 'white' ] );\n\tgui.add( params, 'displayEdges' );\n\tgui.add( params, 'displayProjection' );\n\tgui.add( params, 'useBVH' );\n\tgui.add( params, 'sortEdges' );\n\tgui.add( params, 'rotate' );\n\tgui.add( params, 'regenerate' );\n\n\ttask = updateEdges();\n\n\trender();\n\n}\n\nfunction* updateEdges( runTime = 30 ) {\n\n\toutputContainer.innerText = 'processing: --';\n\tscene.remove( projection );\n\n\t// transform and merge geometries to project into a single model\n\tlet timeStart = window.performance.now();\n\tconst geometries = [];\n\tmodel.updateWorldMatrix( true, true );\n\tmodel.traverse( c => {\n\n\t\tif ( c.geometry ) {\n\n\t\t\tconst clone = c.geometry.clone();\n\t\t\tclone.applyMatrix4( c.matrixWorld );\n\t\t\tfor ( const key in clone.attributes ) {\n\n\t\t\t\tif ( key !== 'position' ) {\n\n\t\t\t\t\tclone.deleteAttribute( key );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometries.push( clone );\n\n\t\t}\n\n\t} );\n\tconst mergedGeometry = mergeBufferGeometries( geometries, false );\n\tconst mergeTime = window.performance.now() - timeStart;\n\n\tyield;\n\n\t// generate the bvh for acceleration\n\ttimeStart = window.performance.now();\n\tconst bvh = new MeshBVH( mergedGeometry );\n\tconst bvhTime = window.performance.now() - timeStart;\n\n\tyield;\n\n\t// generate the candidate edges\n\ttimeStart = window.performance.now();\n\tconst edges = generateEdges( mergedGeometry, new THREE.Vector3( 0, 1, 0 ), 50 );\n\n\tif ( params.sortEdges ) {\n\n\t\tedges.sort( ( a, b ) => {\n\n\t\t\treturn Math.min( a.start.y, a.end.y ) - Math.min( b.start.y, b.end.y );\n\n\t\t} );\n\n\t}\n\n\tconst edgeGenerateTime = window.performance.now() - timeStart;\n\n\tyield;\n\n\tscene.add( projection );\n\n\t// trim the candidate edges\n\tconst finalEdges = [];\n\tconst tempLine = new THREE.Line3();\n\tconst tempRay = new THREE.Ray();\n\tconst tempVec = new THREE.Vector3();\n\n\ttimeStart = window.performance.now();\n\tlet trimTime = 0;\n\tfor ( let i = 0, l = edges.length; i < l; i ++ ) {\n\n\t\tconst line = edges[ i ];\n\t\tif ( isYProjectedLineDegenerate( line ) ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tconst lowestLineY = Math.min( line.start.y, line.end.y );\n\t\tconst overlaps = [];\n\t\tbvh.shapecast( {\n\n\t\t\tintersectsBounds: box => {\n\n\t\t\t\tif ( ! params.useBVH ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the box bounds are above the lowest line point\n\t\t\t\tbox.min.y = Math.min( lowestLineY, box.min.y );\n\t\t\t\ttempRay.origin.copy( line.start );\n\t\t\t\tline.delta( tempRay.direction ).normalize();\n\n\t\t\t\tif ( box.containsPoint( tempRay.origin ) ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tempRay.intersectBox( box, tempVec ) ) {\n\n\t\t\t\t\treturn tempRay.origin.distanceToSquared( tempVec ) < line.distanceSq();\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t// skip the triangle if it is completely below the line\n\t\t\t\tconst highestTriangleY = Math.max( tri.a.y, tri.b.y, tri.c.y );\n\n\t\t\t\tif ( highestTriangleY < lowestLineY ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// if the projected triangle is just a line then don't check it\n\t\t\t\tif ( isYProjectedTriangleDegenerate( tri ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// if this line lies on a triangle edge then don't check it\n\t\t\t\tif ( isLineTriangleEdge( tri, line ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\ttrimToBeneathTriPlane( tri, line, tempLine );\n\n\t\t\t\tif ( isLineAbovePlane( tri.plane, tempLine ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tempLine.distance() < 1e-10 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// compress the edge overlaps so we can easily tell if the whole edge is hidden already\n\t\t\t\t// and exit early\n\t\t\t\tif ( getProjectedOverlaps( tri, line, overlaps ) ) {\n\n\t\t\t\t\tcompressEdgeOverlaps( overlaps );\n\n\t\t\t\t}\n\n\t\t\t\t// if we're hiding the edge entirely now then skip further checks\n\t\t\t\tif ( overlaps.length !== 0 ) {\n\n\t\t\t\t\tconst [ d0, d1 ] = overlaps[ overlaps.length - 1 ];\n\t\t\t\t\treturn d0 === 0.0 && d1 === 1.0;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t} );\n\n\t\toverlapsToLines( line, overlaps, finalEdges );\n\n\t\tconst delta = window.performance.now() - timeStart;\n\t\tif ( delta > runTime ) {\n\n\t\t\toutputContainer.innerText = `processing: ${ ( 100 * i / edges.length ).toFixed( 2 ) }%`;\n\t\t\ttrimTime += delta;\n\n\t\t\tprojection.geometry.dispose();\n\t\t\tprojection.geometry = edgesToGeometry( finalEdges, 0 );\n\t\t\tyield;\n\t\t\ttimeStart = window.performance.now();\n\n\t\t}\n\n\t}\n\n\tprojection.geometry.dispose();\n\tprojection.geometry = edgesToGeometry( finalEdges, 0 );\n\ttrimTime += window.performance.now() - timeStart;\n\n\toutputContainer.innerText =\n\t\t`merge geometry  : ${ mergeTime.toFixed( 2 ) }ms\\n` +\n\t\t`bvh generation  : ${ bvhTime.toFixed( 2 ) }ms\\n` +\n\t\t`edge generation : ${ edgeGenerateTime.toFixed( 2 ) }ms\\n` +\n\t\t`edge trimming   : ${ trimTime.toFixed( 2 ) }ms\\n\\n` +\n\t\t`total time      : ${ ( mergeTime + bvhTime + edgeGenerateTime + trimTime ).toFixed( 2 ) }ms\\n` +\n\t\t`total edges     : ${ finalEdges.length } edges`;\n\n}\n\n\nfunction render() {\n\n\trequestAnimationFrame( render );\n\n\tif ( task ) {\n\n\t\tconst res = task.next();\n\t\tif ( res.done ) {\n\n\t\t\ttask = null;\n\n\t\t}\n\n\t}\n\n\tmodel.visible = params.displayModel === 'color';\n\twhiteModel.visible = params.displayModel === 'white';\n\tlines.visible = params.displayEdges;\n\tprojection.visible = params.displayProjection;\n\n\trenderer.render( scene, camera );\n\n}\n"],"names":["$b429f0f4d7802ecd$var$_upVector","$ilwiq","Vector3","$b429f0f4d7802ecd$export$b2d7c053833d1662","_v0","_v1","_normal","_triangle","Triangle","geometry","projectionDir","thresholdAngle","edges","precision","Math","pow","thresholdDot","cos","MathUtils","DEG2RAD","indexAttr","getIndex","positionAttr","getAttribute","indexCount","count","indexArr","vertKeys","hashes","Array","edgeData","i","getX","a","b","c","fromBufferAttribute","getNormal","round","x","y","z","j","jNext","vecHash0","vecHash1","v0","v1","hash","reverseHash","otherNormal","normal","meetsThreshold","dot","projectionThreshold","sign","line","Line3","start","copy","end","push","index0","index1","clone","key","$b429f0f4d7802ecd$export$634af0a80e65979f","_dir0","_dir1","_tempDir","_orthoPlane","Plane","_line0","_line1","_tempLine","triangle","lineTarget","needsUpdate","getArea","points","plane","delta","cross","normalize","setFromNormalAndCoplanarPoint","intersectCount","p1","p2","distanceToPoint","intersectLine","p","distanceTo","tmp","s1","e1","s2","e2","separated1","separated2","subVectors","$b429f0f4d7802ecd$export$218b3458630594e8","testLine","point","target","$b429f0f4d7802ecd$export$a91bb2cd4a0a5275","lerpVectors","$b429f0f4d7802ecd$export$cec4aea73fa71fc5","_upVector","abs","$b429f0f4d7802ecd$export$97cada60b6f00a63","tri","update","$b429f0f4d7802ecd$export$6ce1ecae0cd1cc55","triPoints","matches","tp","distanceToSquared","$b429f0f4d7802ecd$export$b8e1c20578f7559e","_target","_tempVec0","_tempVec1","_line","_tri","$4CEV9","ExtendedTriangle","overlapsTarget","d0","length","d1","min","max","Float32Array","$b429f0f4d7802ecd$export$3240a8dc8bb0ce4c","_lineDirection","_planeHit","_centerPoint","_planePoint","testPoint","flipped","$b429f0f4d7802ecd$export$fbbde8a5b23b7b65","newLine","overlaps","$b429f0f4d7802ecd$export$84bed164e326c2f0","invOverlaps","l","invOverlap","overlap","i1","l1","$b429f0f4d7802ecd$export$c58cbc83033eedad","edgeArray","edgeGeom","BufferGeometry","edgeBuffer","BufferAttribute","setAttribute","sort","prevOverlap","splice","$c9fdec40e3bbb10a$var$params","displayModel","displayEdges","displayProjection","useBVH","sortEdges","rotate","$c9fdec40e3bbb10a$var$group","quaternion","random","position","set","updateMatrixWorld","box","Box3","setFromObject","$c9fdec40e3bbb10a$var$model","getCenter","multiplyScalar","regenerate","$c9fdec40e3bbb10a$var$task","$c9fdec40e3bbb10a$var$updateEdges","$c9fdec40e3bbb10a$var$renderer","$c9fdec40e3bbb10a$var$camera","$c9fdec40e3bbb10a$var$scene","$c9fdec40e3bbb10a$var$gui","$c9fdec40e3bbb10a$var$controls","$c9fdec40e3bbb10a$var$lines","$c9fdec40e3bbb10a$var$projection","$c9fdec40e3bbb10a$var$whiteModel","$c9fdec40e3bbb10a$var$outputContainer","runTime","innerText","remove","timeStart","window","performance","now","geometries","updateWorldMatrix","traverse","applyMatrix4","matrixWorld","attributes","deleteAttribute","mergedGeometry","$7ePFa","mergeBufferGeometries","mergeTime","bvh","MeshBVH","bvhTime","edgeGenerateTime","add","finalEdges","tempLine","tempRay","Ray","tempVec","trimTime","lowestLineY","shapecast","intersectsBounds","origin","direction","containsPoint","intersectBox","distanceSq","intersectsTriangle","distance","toFixed","dispose","$c9fdec40e3bbb10a$var$render","requestAnimationFrame","next","done","visible","render","document","getElementById","WebGLRenderer","antialias","setPixelRatio","devicePixelRatio","setSize","innerWidth","innerHeight","setClearColor","outputEncoding","sRGBEncoding","body","appendChild","domElement","Scene","light","DirectionalLight","AmbientLight","Group","addEventListener","aspect","updateProjectionMatrix","gltf","$7lx9d","GLTFLoader","setMeshoptDecoder","$kp7Te","MeshoptDecoder","loadAsync","scene","whiteMaterial","MeshStandardMaterial","material","geomLines","LineSegments","EdgesGeometry","LineBasicMaterial","color","scale","PerspectiveCamera","setScalar","$5Rd1x","OrbitControls","$jiuw3","GUI","$c9fdec40e3bbb10a$var$init"],"version":3,"file":"edgeProjection.59721e0c.js.map"}