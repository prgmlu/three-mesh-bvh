function e(e,t,r,o){Object.defineProperty(e,t,{get:r,set:o,enumerable:!0,configurable:!0})}var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},r={},o={},i=t.parcelRequire4485;null==i&&((i=function(e){if(e in r)return r[e].exports;if(e in o){var t=o[e];delete o[e];var i={id:e,exports:{}};return r[e]=i,t.call(i.exports,i,i.exports),i.exports}var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}).register=function(e,t){o[e]=t},t.parcelRequire4485=i),i.register("7ePFa",(function(t,r){e(t.exports,"mergeVertices",(()=>s)),e(t.exports,"toTrianglesDrawMode",(()=>l)),e(t.exports,"mergeBufferGeometries",(()=>u));var o=i("ilwiq");function n(e){let t,r,i,n=0;for(let o=0;o<e.length;++o){const s=e[o];if(s.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=s.array.constructor),t!==s.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=s.itemSize),r!==s.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===i&&(i=s.normalized),i!==s.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;n+=s.array.length}const s=new t(n);let l=0;for(let t=0;t<e.length;++t)s.set(e[t].array,l),l+=e[t].array.length;return new o.BufferAttribute(s,r,i)}function s(e,t=1e-4){t=Math.max(t,Number.EPSILON);const r={},i=e.getIndex(),n=e.getAttribute("position"),s=i?i.count:n.count;let l=0;const u=Object.keys(e.attributes),a={},f={},m=[],c=["getX","getY","getZ","getW"],g=["setX","setY","setZ","setW"];for(let t=0,r=u.length;t<r;t++){const r=u[t],i=e.attributes[r];a[r]=new o.BufferAttribute(new i.array.constructor(i.count*i.itemSize),i.itemSize,i.normalized);const n=e.morphAttributes[r];n&&(f[r]=new o.BufferAttribute(new n.array.constructor(n.count*n.itemSize),n.itemSize,n.normalized))}const d=Math.log10(1/t),h=Math.pow(10,d);for(let t=0;t<s;t++){const o=i?i.getX(t):t;let n="";for(let t=0,r=u.length;t<r;t++){const r=u[t],i=e.getAttribute(r),s=i.itemSize;for(let e=0;e<s;e++)n+=~~(i[c[e]](o)*h)+","}if(n in r)m.push(r[n]);else{for(let t=0,r=u.length;t<r;t++){const r=u[t],i=e.getAttribute(r),n=e.morphAttributes[r],s=i.itemSize,m=a[r],d=f[r];for(let e=0;e<s;e++){const t=c[e],r=g[e];if(m[r](l,i[t](o)),n)for(let e=0,i=n.length;e<i;e++)d[e][r](l,n[e][t](o))}}r[n]=l,m.push(l),l++}}const b=e.clone();for(const t in e.attributes){const e=a[t];if(b.setAttribute(t,new o.BufferAttribute(e.array.slice(0,l*e.itemSize),e.itemSize,e.normalized)),t in f)for(let e=0;e<f[t].length;e++){const r=f[t][e];b.morphAttributes[t][e]=new o.BufferAttribute(r.array.slice(0,l*r.itemSize),r.itemSize,r.normalized)}}return b.setIndex(m),b}function l(e,t){if(t===o.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===o.TriangleFanDrawMode||t===o.TriangleStripDrawMode){let r=e.getIndex();if(null===r){const t=[],o=e.getAttribute("position");if(void 0===o)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<o.count;e++)t.push(e);e.setIndex(t),r=e.getIndex()}const i=r.count-2,n=[];if(t===o.TriangleFanDrawMode)for(let e=1;e<=i;e++)n.push(r.getX(0)),n.push(r.getX(e)),n.push(r.getX(e+1));else for(let e=0;e<i;e++)e%2==0?(n.push(r.getX(e)),n.push(r.getX(e+1)),n.push(r.getX(e+2))):(n.push(r.getX(e+2)),n.push(r.getX(e+1)),n.push(r.getX(e)));n.length/3!==i&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=e.clone();return s.setIndex(n),s.clearGroups(),s}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}function u(e,t=!1){return console.warn("THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries()."),function(e,t=!1){const r=null!==e[0].index,i=new Set(Object.keys(e[0].attributes)),s=new Set(Object.keys(e[0].morphAttributes)),l={},u={},a=e[0].morphTargetsRelative,f=new o.BufferGeometry;let m=0;for(let o=0;o<e.length;++o){const n=e[o];let c=0;if(r!==(null!==n.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in n.attributes){if(!i.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===l[e]&&(l[e]=[]),l[e].push(n.attributes[e]),c++}if(c!==i.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+". Make sure all geometries have the same number of attributes."),null;if(a!==n.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in n.morphAttributes){if(!s.has(e))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===u[e]&&(u[e]=[]),u[e].push(n.morphAttributes[e])}if(t){let e;if(r)e=n.index.count;else{if(void 0===n.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+o+". The geometry must have either an index or a position attribute"),null;e=n.attributes.position.count}f.addGroup(m,e,o),m+=e}}if(r){let t=0;const r=[];for(let o=0;o<e.length;++o){const i=e[o].index;for(let e=0;e<i.count;++e)r.push(i.getX(e)+t);t+=e[o].attributes.position.count}f.setIndex(r)}for(const e in l){const t=n(l[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;f.setAttribute(e,t)}for(const e in u){const t=u[e][0].length;if(0===t)break;f.morphAttributes=f.morphAttributes||{},f.morphAttributes[e]=[];for(let r=0;r<t;++r){const t=[];for(let o=0;o<u[e].length;++o)t.push(u[e][o][r]);const o=n(t);if(!o)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;f.morphAttributes[e].push(o)}}return f}(e,t)}}));
//# sourceMappingURL=characterMovement.64910e00.js.map
