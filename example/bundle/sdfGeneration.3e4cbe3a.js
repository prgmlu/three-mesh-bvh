function t(t){return t&&t.__esModule?t.default:t}var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},n={},r={},i=e.parcelRequire4485;null==i&&((i=function(t){if(t in n)return n[t].exports;if(t in r){var e=r[t];delete r[t];var i={id:t,exports:{}};return n[t]=i,e.call(i.exports,i,i.exports),i.exports}var a=new Error("Cannot find module '"+t+"'");throw a.code="MODULE_NOT_FOUND",a}).register=function(t,e){r[t]=e},e.parcelRequire4485=i),i("27Lyk").register(JSON.parse('{"1WzX2":"sdfGeneration.3e4cbe3a.js","b4BBl":"generateAsync.worker.5bf93d10.js","9JIya":"asyncGenerate.924881df.js","1o4q0":"characterMovement.00d7d3c9.js","bEy7u":"asyncGenerate.6b6e94f2.js","atdpM":"characterMovement.64910e00.js","7RGMC":"characterMovement.9329e59d.js","efnpd":"cpuPathTracing.c866b4cf.js","817sr":"asyncGenerate.4d3a79b0.js","fI6hf":"clippedEdges.c7f3e0bd.js"}'));var a,o,s=i("ilwiq"),l=i("7lx9d"),d=i("RPVlj"),c=i("5Rd1x"),u=i("jiuw3"),f={};a=f,o=function(){var t=function(){function e(t){return i.appendChild(t.dom),t}function n(t){for(var e=0;e<i.children.length;e++)i.children[e].style.display=e===t?"block":"none";r=t}var r=0,i=document.createElement("div");i.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",i.addEventListener("click",(function(t){t.preventDefault(),n(++r%i.children.length)}),!1);var a=(performance||Date).now(),o=a,s=0,l=e(new t.Panel("FPS","#0ff","#002")),d=e(new t.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var c=e(new t.Panel("MB","#f08","#201"));return n(0),{REVISION:16,dom:i,addPanel:e,showPanel:n,begin:function(){a=(performance||Date).now()},end:function(){s++;var t=(performance||Date).now();if(d.update(t-a,200),t>o+1e3&&(l.update(1e3*s/(t-o),100),o=t,s=0,c)){var e=performance.memory;c.update(e.usedJSHeapSize/1048576,e.jsHeapSizeLimit/1048576)}return t},update:function(){a=this.end()},domElement:i,setMode:n}};return t.Panel=function(t,e,n){var r=1/0,i=0,a=Math.round,o=a(window.devicePixelRatio||1),s=80*o,l=48*o,d=3*o,c=2*o,u=3*o,f=15*o,m=74*o,v=30*o,x=document.createElement("canvas");x.width=s,x.height=l,x.style.cssText="width:80px;height:48px";var p=x.getContext("2d");return p.font="bold "+9*o+"px Helvetica,Arial,sans-serif",p.textBaseline="top",p.fillStyle=n,p.fillRect(0,0,s,l),p.fillStyle=e,p.fillText(t,d,c),p.fillRect(u,f,m,v),p.fillStyle=n,p.globalAlpha=.9,p.fillRect(u,f,m,v),{dom:x,update:function(l,g){r=Math.min(r,l),i=Math.max(i,l),p.fillStyle=n,p.globalAlpha=1,p.fillRect(0,0,s,f),p.fillStyle=e,p.fillText(a(l)+" "+t+" ("+a(r)+"-"+a(i)+")",d,c),p.drawImage(x,u+o,f,m-o,v,u,f,m-o,v),p.fillRect(u+m-o,f,o,v),p.fillStyle=n,p.globalAlpha=.9,p.fillRect(u+m-o,f,o,a((1-l/g)*v))}}},t},"object"==typeof f?f=o():"function"==typeof define&&define.amd?define(o):a.Stats=o();var m=i("8todg"),v=i("4CEV9");s=i("ilwiq"),v=i("4CEV9");class x extends s.ShaderMaterial{constructor(t){super({uniforms:{matrix:{value:new s.Matrix4},zValue:{value:0},bvh:{value:new v.MeshBVHUniformStruct}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:`\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\n\t\t\t\t${v.shaderStructs}\n\t\t\t\t${v.shaderIntersectFunction}\n\t\t\t\t${v.shaderDistanceFunction}\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform float zValue;\n\t\t\t\tuniform mat4 matrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// compute the point in space to check\n\t\t\t\t\tvec3 point = vec3( vUv, zValue );\n\t\t\t\t\tpoint -= vec3( 0.5 );\n\t\t\t\t\tpoint = ( matrix * vec4( point, 1.0 ) ).xyz;\n\n\t\t\t\t\t// retrieve the distance and other values\n\t\t\t\t\tuvec4 faceIndices;\n\t\t\t\t\tvec3 faceNormal;\n\t\t\t\t\tvec3 barycoord;\n\t\t\t\t\tfloat side;\n\t\t\t\t\tvec3 outPoint;\n\t\t\t\t\tfloat dist = bvhClosestPointToPoint( bvh, point.xyz, faceIndices, faceNormal, barycoord, side, outPoint );\n\n\t\t\t\t\t// if the triangle side is the back then it must be on the inside and the value negative\n\t\t\t\t\tgl_FragColor = vec4( side * dist, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t`}),this.setValues(t)}}s=i("ilwiq");class p extends s.ShaderMaterial{constructor(t){super({defines:{DISPLAY_GRID:0},uniforms:{sdfTex:{value:null},layer:{value:0},layers:{value:0}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:"\n\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler3D sdfTex;\n\t\t\t\tuniform float layer;\n\t\t\t\tuniform float layers;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#if DISPLAY_GRID\n\n\t\t\t\t\tfloat dim = ceil( sqrt( layers ) );\n\t\t\t\t\tvec2 cell = floor( vUv * dim );\n\t\t\t\t\tvec2 frac = vUv * dim - cell;\n\t\t\t\t\tfloat zLayer = ( cell.y * dim + cell.x ) / ( dim * dim );\n\n\t\t\t\t\tfloat dist = texture( sdfTex, vec3( frac, zLayer ) ).r;\n\t\t\t\t\tgl_FragColor.rgb = dist > 0.0 ? vec3( 0, dist, 0 ) : vec3( - dist, 0, 0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\tfloat dist = texture( sdfTex, vec3( vUv, layer ) ).r;\n\t\t\t\t\tgl_FragColor.rgb = dist > 0.0 ? vec3( 0, dist, 0 ) : vec3( - dist, 0, 0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}\n\t\t\t"}),this.setValues(t)}}s=i("ilwiq");class g extends s.ShaderMaterial{constructor(t){super({defines:{MAX_STEPS:500,SURFACE_EPSILON:.001},uniforms:{surface:{value:0},sdfTex:{value:null},normalStep:{value:new s.Vector3},projectionInverse:{value:new s.Matrix4},sdfTransformInverse:{value:new s.Matrix4}},vertexShader:"\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t",fragmentShader:"\n\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform float surface;\n\t\t\t\tuniform sampler3D sdfTex;\n\t\t\t\tuniform vec3 normalStep;\n\t\t\t\tuniform mat4 projectionInverse;\n\t\t\t\tuniform mat4 sdfTransformInverse;\n\n\t\t\t\t#include <common>\n\n\t\t\t\t// distance to box bounds\n\t\t\t\tvec2 rayBoxDist( vec3 boundsMin, vec3 boundsMax, vec3 rayOrigin, vec3 rayDir ) {\n\n\t\t\t\t\tvec3 t0 = ( boundsMin - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 t1 = ( boundsMax - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 tmin = min( t0, t1 );\n\t\t\t\t\tvec3 tmax = max( t0, t1 );\n\n\t\t\t\t\tfloat distA = max( max( tmin.x, tmin.y ), tmin.z );\n\t\t\t\t\tfloat distB = min( tmax.x, min( tmax.y, tmax.z ) );\n\n\t\t\t\t\tfloat distToBox = max( 0.0, distA );\n\t\t\t\t\tfloat distInsideBox = max( 0.0, distB - distToBox );\n\t\t\t\t\treturn vec2( distToBox, distInsideBox );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// get the inverse of the sdf box transform\n\t\t\t\t\tmat4 sdfTransform = inverse( sdfTransformInverse );\n\n\t\t\t\t\t// convert the uv to clip space for ray transformation\n\t\t\t\t\tvec2 clipSpace = 2.0 * vUv - vec2( 1.0 );\n\n\t\t\t\t\t// get world ray direction\n\t\t\t\t\tvec3 rayOrigin = vec3( 0.0 );\n\t\t\t\t\tvec4 homogenousDirection = projectionInverse * vec4( clipSpace, - 1.0, 1.0 );\n\t\t\t\t\tvec3 rayDirection = normalize( homogenousDirection.xyz / homogenousDirection.w );\n\n\t\t\t\t\t// transform ray into local coordinates of sdf bounds\n\t\t\t\t\tvec3 sdfRayOrigin = ( sdfTransformInverse * vec4( rayOrigin, 1.0 ) ).xyz;\n\t\t\t\t\tvec3 sdfRayDirection = normalize( ( sdfTransformInverse * vec4( rayDirection, 0.0 ) ).xyz );\n\n\t\t\t\t\t// find whether our ray hits the box bounds in the local box space\n\t\t\t\t\tvec2 boxIntersectionInfo = rayBoxDist( vec3( - 0.5 ), vec3( 0.5 ), sdfRayOrigin, sdfRayDirection );\n\t\t\t\t\tfloat distToBox = boxIntersectionInfo.x;\n\t\t\t\t\tfloat distInsideBox = boxIntersectionInfo.y;\n\t\t\t\t\tbool intersectsBox = distInsideBox > 0.0;\n\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\tif ( intersectsBox ) {\n\n\t\t\t\t\t\t// find the surface point in world space\n\t\t\t\t\t\tbool intersectsSurface = false;\n\t\t\t\t\t\tvec4 localPoint = vec4( sdfRayOrigin + sdfRayDirection * ( distToBox + 1e-5 ), 1.0 );\n\t\t\t\t\t\tvec4 point = sdfTransform * localPoint;\n\n\t\t\t\t\t\t// ray march\n\t\t\t\t\t\tfor ( int i = 0; i < MAX_STEPS; i ++ ) {\n\n\t\t\t\t\t\t\t// sdf box extends from - 0.5 to 0.5\n\t\t\t\t\t\t\t// transform into the local bounds space [ 0, 1 ] and check if we're inside the bounds\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tif ( uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || uv.z < 0.0 || uv.z > 1.0 ) {\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// get the distance to surface and exit the loop if we're close to the surface\n\t\t\t\t\t\t\tfloat distanceToSurface = texture2D( sdfTex, uv ).r - surface;\n\t\t\t\t\t\t\tif ( distanceToSurface < SURFACE_EPSILON ) {\n\n\t\t\t\t\t\t\t\tintersectsSurface = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// step the ray\n\t\t\t\t\t\t\tpoint.xyz += rayDirection * abs( distanceToSurface );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the surface normal\n\t\t\t\t\t\tif ( intersectsSurface ) {\n\n\t\t\t\t\t\t\t// compute the surface normal\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tfloat dx = texture( sdfTex, uv + vec3( normalStep.x, 0.0, 0.0 ) ).r - texture( sdfTex, uv - vec3( normalStep.x, 0.0, 0.0 ) ).r;\n\t\t\t\t\t\t\tfloat dy = texture( sdfTex, uv + vec3( 0.0, normalStep.y, 0.0 ) ).r - texture( sdfTex, uv - vec3( 0.0, normalStep.y, 0.0 ) ).r;\n\t\t\t\t\t\t\tfloat dz = texture( sdfTex, uv + vec3( 0.0, 0.0, normalStep.z ) ).r - texture( sdfTex, uv - vec3( 0.0, 0.0, normalStep.z ) ).r;\n\t\t\t\t\t\t\tvec3 normal = normalize( vec3( dx, dy, dz ) );\n\n\t\t\t\t\t\t\t// compute some basic lighting effects\n\t\t\t\t\t\t\tvec3 lightDirection = normalize( vec3( 1.0 ) );\n\t\t\t\t\t\t\tfloat lightIntensity =\n\t\t\t\t\t\t\t\tsaturate( dot( normal, lightDirection ) ) +\n\t\t\t\t\t\t\t\tsaturate( dot( normal, - lightDirection ) ) * 0.05 +\n\t\t\t\t\t\t\t\t0.1;\n\t\t\t\t\t\t\tgl_FragColor.rgb = vec3( lightIntensity );\n\t\t\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}\n\t\t\t"}),this.setValues(t)}}var y=i("kp7Te");const h={gpuGeneration:!0,resolution:75,margin:.2,regenerate:()=>E(),mode:"raymarching",layer:0,surface:.1};let w,b,S,T,D,M,I,F,z,P,R,B,j,C,V;const _=new s.Matrix4;function L(){T&&T.destroy(),h.layer=Math.min(h.resolution,h.layer),T=new u.GUI;const t=T.addFolder("generation");t.add(h,"gpuGeneration"),t.add(h,"resolution",10,200,1),t.add(h,"margin",0,1),t.add(h,"regenerate");const e=T.addFolder("display");e.add(h,"mode",["geometry","raymarching","layer","grid layers"]).onChange((()=>{L()})),"layer"===h.mode&&e.add(h,"layer",0,h.resolution,1),"raymarching"===h.mode&&e.add(h,"surface",-.2,.5)}function E(){const t=h.resolution,e=new s.Matrix4,n=new s.Vector3,r=new s.Quaternion,i=new s.Vector3;z.boundingBox.getCenter(n),i.subVectors(z.boundingBox.max,z.boundingBox.min),i.x+=2*h.margin,i.y+=2*h.margin,i.z+=2*h.margin,e.compose(n,r,i),_.copy(e).invert(),M.box.copy(z.boundingBox),M.box.min.x-=h.margin,M.box.min.y-=h.margin,M.box.min.z-=h.margin,M.box.max.x+=h.margin,M.box.max.y+=h.margin,M.box.max.z+=h.margin,P&&P.dispose();const a=1/t,o=.5*a,l=window.performance.now();if(h.gpuGeneration){P=new s.WebGL3DRenderTarget(t,t,t),P.texture.format=s.RedFormat,P.texture.type=s.FloatType,P.texture.minFilter=s.LinearFilter,P.texture.magFilter=s.LinearFilter,B.material.uniforms.bvh.value.updateFrom(F),B.material.uniforms.matrix.value.copy(e);for(let e=0;e<t;e++)B.material.uniforms.zValue.value=e*a+o,w.setRenderTarget(P,e),B.render(w);w.readRenderTargetPixels(P,0,0,1,1,new Float32Array(4)),w.setRenderTarget(null)}else{P=new s.Data3DTexture(new Float32Array(t**3),t,t,t),P.format=s.RedFormat,P.type=s.FloatType,P.minFilter=s.LinearFilter,P.magFilter=s.LinearFilter,P.needsUpdate=!0;const n=z.attributes.position,r=z.index,i=new s.Vector3,l=new s.Vector3,d=new s.Vector3,c=new s.Triangle,u={};for(let s=0;s<t;s++)for(let f=0;f<t;f++)for(let m=0;m<t;m++){i.set(o+s*a-.5,o+f*a-.5,o+m*a-.5).applyMatrix4(e);const v=s+f*t+m*t*t,x=F.closestPointToPoint(i,u).distance,p=u.faceIndex,g=r.getX(3*p+0),y=r.getX(3*p+1),h=r.getX(3*p+2);c.setFromAttributeAndIndices(n,g,y,h),c.getNormal(l),d.subVectors(u.point,i),P.image.data[v]=l.dot(d)>0?-x:x}}const d=window.performance.now()-l;I.innerText=`${d.toFixed(2)}ms`,L()}!function(){I=document.getElementById("output"),w=new s.WebGLRenderer({antialias:!0}),w.setPixelRatio(window.devicePixelRatio),w.setSize(window.innerWidth,window.innerHeight),w.setClearColor(0,0),w.outputEncoding=s.sRGBEncoding,document.body.appendChild(w.domElement),S=new s.Scene;const e=new s.DirectionalLight(16777215,1);e.position.set(1,1,1),S.add(e),S.add(new s.AmbientLight(16777215,.2)),b=new s.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,50),b.position.set(1,1,2),b.far=100,b.updateProjectionMatrix(),M=new s.Box3Helper(new s.Box3),S.add(M),new c.OrbitControls(b,w.domElement),D=new(t(f)),document.body.appendChild(D.dom),B=new d.FullScreenQuad(new x),j=new d.FullScreenQuad(new p),C=new d.FullScreenQuad(new g),V=new m.GenerateMeshBVHWorker,(new l.GLTFLoader).setMeshoptDecoder(y.MeshoptDecoder).loadAsync("https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/stanford-bunny/bunny.glb").then((t=>{t.scene.updateMatrixWorld(!0);const e=new v.StaticGeometryGenerator(t.scene);return e.attributes=["position","normal"],e.useGroups=!1,z=e.generate().center(),V.generate(z,{maxLeafTris:1})})).then((t=>{F=t,R=new s.Mesh(z,new s.MeshStandardMaterial),S.add(R),E()})),L(),window.addEventListener("resize",(function(){b.aspect=window.innerWidth/window.innerHeight,b.updateProjectionMatrix(),w.setSize(window.innerWidth,window.innerHeight)}),!1)}(),function t(){if(D.update(),requestAnimationFrame(t),!P)return;if("geometry"===h.mode)w.render(S,b);else if("layer"===h.mode||"grid layers"===h.mode){let t;const e=j.material;P.isData3DTexture?(e.uniforms.layer.value=h.layer/P.image.width,e.uniforms.sdfTex.value=P,t=P):(e.uniforms.layer.value=h.layer/P.width,e.uniforms.sdfTex.value=P.texture,t=P.texture),e.uniforms.layers.value=t.image.width;const n="layer"===h.mode?0:1;n!==e.defines.DISPLAY_GRID&&(e.defines.DISPLAY_GRID=n,e.needsUpdate=!0),j.render(w)}else if("raymarching"===h.mode){let t;b.updateMatrixWorld(),R.updateMatrixWorld(),t=P.isData3DTexture?P:P.texture;const{width:e,depth:n,height:r}=t.image;C.material.uniforms.sdfTex.value=t,C.material.uniforms.normalStep.value.set(1/e,1/r,1/n),C.material.uniforms.surface.value=h.surface,C.material.uniforms.projectionInverse.value.copy(b.projectionMatrixInverse),C.material.uniforms.sdfTransformInverse.value.copy(R.matrixWorld).invert().premultiply(_).multiply(b.matrixWorld),C.render(w)}}();
//# sourceMappingURL=sdfGeneration.3e4cbe3a.js.map
