{"mappings":"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","sources":["node_modules/stats.js/build/stats.min.js","example/selection.js"],"sourcesContent":["// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){\"object\"===typeof exports&&\"undefined\"!==typeof module?module.exports=e():\"function\"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel(\"FPS\",\"#0ff\",\"#002\")),h=e(new f.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var t=e(new f.Panel(\"MB\",\"#f08\",\"#201\"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=h;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+\" \"+e+\" (\"+g(c)+\"-\"+g(k)+\")\",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n","import * as THREE from 'three';\nimport Stats from 'stats.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport {\n\tMeshBVHVisualizer,\n\tMeshBVH,\n\tCONTAINED,\n\tINTERSECTED,\n\tNOT_INTERSECTED,\n} from '..';\n\nconst params = {\n\n\ttoolMode: 'lasso',\n\tselectionMode: 'intersection',\n\tliveUpdate: false,\n\tselectModel: false,\n\twireframe: false,\n\tuseBoundsTree: true,\n\n\tdisplayHelper: false,\n\thelperDepth: 10,\n\trotate: true,\n\n};\n\nlet renderer, camera, scene, gui, stats, controls, selectionShape, mesh, helper;\nlet highlightMesh, highlightWireframeMesh, outputContainer, group;\nconst selectionPoints = [];\nlet dragging = false;\nlet selectionShapeNeedsUpdate = false;\nlet selectionNeedsUpdate = false;\n\ninit();\nrender();\n\nfunction init() {\n\n\toutputContainer = document.getElementById( 'output' );\n\n\tconst bgColor = new THREE.Color( 0x263238 );\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( bgColor, 1 );\n\trenderer.shadowMap.enabled = true;\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\n\tconst light = new THREE.DirectionalLight( 0xffffff, 1 );\n\tlight.castShadow = true;\n\tlight.shadow.mapSize.set( 2048, 2048 );\n\tlight.position.set( 10, 10, 10 );\n\tscene.add( light );\n\tscene.add( new THREE.AmbientLight( 0xb0bec5, 0.8 ) );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( 2, 4, 6 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\tscene.add( camera );\n\n\t// selection shape\n\tselectionShape = new THREE.Line();\n\tselectionShape.material.color.set( 0xff9800 ).convertSRGBToLinear();\n\tselectionShape.renderOrder = 1;\n\tselectionShape.position.z = - .2;\n\tselectionShape.depthTest = false;\n\tselectionShape.scale.setScalar( 1 );\n\tcamera.add( selectionShape );\n\n\t// group for rotation\n\tgroup = new THREE.Group();\n\tscene.add( group );\n\n\t// base mesh\n\tmesh = new THREE.Mesh(\n\t\tnew THREE.TorusKnotGeometry( 1.5, 0.5, 500, 60 ).toNonIndexed(),\n\t\tnew THREE.MeshStandardMaterial( {\n\t\t\tpolygonOffset: true,\n\t\t\tpolygonOffsetFactor: 1,\n\t\t} )\n\t);\n\tmesh.geometry.boundsTree = new MeshBVH( mesh.geometry );\n\tmesh.geometry.setAttribute( 'color', new THREE.Uint8BufferAttribute(\n\t\tnew Array( mesh.geometry.index.count * 3 ).fill( 255 ), 3, true\n\t) );\n\tmesh.castShadow = true;\n\tmesh.receiveShadow = true;\n\tgroup.add( mesh );\n\n\thelper = new MeshBVHVisualizer( mesh, 10 );\n\tgroup.add( helper );\n\n\t// meshes for selection highlights\n\thighlightMesh = new THREE.Mesh();\n\thighlightMesh.geometry = mesh.geometry.clone();\n\thighlightMesh.geometry.drawRange.count = 0;\n\thighlightMesh.material = new THREE.MeshBasicMaterial( {\n\t\topacity: 0.05,\n\t\ttransparent: true,\n\t\tdepthWrite: false,\n\t} );\n\thighlightMesh.material.color.set( 0xff9800 ).convertSRGBToLinear();\n\thighlightMesh.renderOrder = 1;\n\tgroup.add( highlightMesh );\n\n\thighlightWireframeMesh = new THREE.Mesh();\n\thighlightWireframeMesh.geometry = highlightMesh.geometry;\n\thighlightWireframeMesh.material = new THREE.MeshBasicMaterial( {\n\t\topacity: 0.25,\n\t\ttransparent: true,\n\t\twireframe: true,\n\t\tdepthWrite: false,\n\t} );\n\thighlightWireframeMesh.material.color.copy( highlightMesh.material.color );\n\thighlightWireframeMesh.renderOrder = 2;\n\tgroup.add( highlightWireframeMesh );\n\n\t// add floor\n\tconst gridHelper = new THREE.GridHelper( 10, 10, 0xffffff, 0xffffff );\n\tgridHelper.material.opacity = 0.2;\n\tgridHelper.material.transparent = true;\n\tgridHelper.position.y = - 2.75;\n\tscene.add( gridHelper );\n\n\tconst shadowPlane = new THREE.Mesh(\n\t\tnew THREE.PlaneBufferGeometry(),\n\t\tnew THREE.ShadowMaterial( { color: 0, opacity: 0.2, depthWrite: false } )\n\t);\n\tshadowPlane.position.y = - 2.74;\n\tshadowPlane.rotation.x = - Math.PI / 2;\n\tshadowPlane.scale.setScalar( 20 );\n\tshadowPlane.renderOrder = 2;\n\tshadowPlane.receiveShadow = true;\n\tscene.add( shadowPlane );\n\n\t// stats setup\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\t// controls\n\tcontrols = new OrbitControls( camera, renderer.domElement );\n\tcontrols.minDistance = 3;\n\tcontrols.touches.ONE = THREE.TOUCH.PAN;\n\tcontrols.mouseButtons.LEFT = THREE.MOUSE.PAN;\n\tcontrols.touches.TWO = THREE.TOUCH.ROTATE;\n\tcontrols.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;\n\tcontrols.enablePan = false;\n\n\t// gui\n\tgui = new GUI();\n\tconst selectionFolder = gui.addFolder( 'selection' );\n\tselectionFolder.add( params, 'toolMode', [ 'lasso', 'box' ] );\n\tselectionFolder.add( params, 'selectionMode', [ 'centroid', 'centroid-visible', 'intersection' ] );\n\tselectionFolder.add( params, 'selectModel' );\n\tselectionFolder.add( params, 'liveUpdate' );\n\tselectionFolder.add( params, 'useBoundsTree' );\n\tselectionFolder.open();\n\n\tconst displayFolder = gui.addFolder( 'display' );\n\tdisplayFolder.add( params, 'wireframe' );\n\tdisplayFolder.add( params, 'rotate' );\n\tdisplayFolder.add( params, 'displayHelper' );\n\tdisplayFolder.add( params, 'helperDepth', 1, 30, 1 ).onChange( v => {\n\n\t\thelper.depth = v;\n\t\thelper.update();\n\n\t} );\n\tdisplayFolder.open();\n\tgui.open();\n\n\t// handle building lasso shape\n\tlet startX = - Infinity;\n\tlet startY = - Infinity;\n\n\tlet prevX = - Infinity;\n\tlet prevY = - Infinity;\n\n\tconst tempVec0 = new THREE.Vector2();\n\tconst tempVec1 = new THREE.Vector2();\n\tconst tempVec2 = new THREE.Vector2();\n\trenderer.domElement.addEventListener( 'pointerdown', e => {\n\n\t\tprevX = e.clientX;\n\t\tprevY = e.clientY;\n\t\tstartX = ( e.clientX / window.innerWidth ) * 2 - 1;\n\t\tstartY = - ( ( e.clientY / window.innerHeight ) * 2 - 1 );\n\t\tselectionPoints.length = 0;\n\t\tdragging = true;\n\n\t} );\n\n\trenderer.domElement.addEventListener( 'pointerup', () => {\n\n\t\tselectionShape.visible = false;\n\t\tdragging = false;\n\t\tif ( selectionPoints.length ) {\n\n\t\t\tselectionNeedsUpdate = true;\n\n\t\t}\n\n\t} );\n\n\trenderer.domElement.addEventListener( 'pointermove', e => {\n\n\t\t// If the left mouse button is not pressed\n\t\tif ( ( 1 & e.buttons ) === 0 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst ex = e.clientX;\n\t\tconst ey = e.clientY;\n\n\t\tconst nx = ( e.clientX / window.innerWidth ) * 2 - 1;\n\t\tconst ny = - ( ( e.clientY / window.innerHeight ) * 2 - 1 );\n\n\t\tif ( params.toolMode === 'box' ) {\n\n\t\t\t// set points for the corner of the box\n\t\t\tselectionPoints.length = 3 * 5;\n\n\t\t\tselectionPoints[ 0 ] = startX;\n\t\t\tselectionPoints[ 1 ] = startY;\n\t\t\tselectionPoints[ 2 ] = 0;\n\n\t\t\tselectionPoints[ 3 ] = nx;\n\t\t\tselectionPoints[ 4 ] = startY;\n\t\t\tselectionPoints[ 5 ] = 0;\n\n\t\t\tselectionPoints[ 6 ] = nx;\n\t\t\tselectionPoints[ 7 ] = ny;\n\t\t\tselectionPoints[ 8 ] = 0;\n\n\t\t\tselectionPoints[ 9 ] = startX;\n\t\t\tselectionPoints[ 10 ] = ny;\n\t\t\tselectionPoints[ 11 ] = 0;\n\n\t\t\tselectionPoints[ 12 ] = startX;\n\t\t\tselectionPoints[ 13 ] = startY;\n\t\t\tselectionPoints[ 14 ] = 0;\n\n\t\t\tif ( ex !== prevX || ey !== prevY ) {\n\n\t\t\t\tselectionShapeNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t\tprevX = ex;\n\t\t\tprevY = ey;\n\t\t\tselectionShape.visible = true;\n\t\t\tif ( params.liveUpdate ) {\n\n\t\t\t\tselectionNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If the mouse hasn't moved a lot since the last point\n\t\t\tif (\n\t\t\t\tMath.abs( ex - prevX ) >= 3 ||\n\t\t\t\tMath.abs( ey - prevY ) >= 3\n\t\t\t) {\n\n\t\t\t\t// Check if the mouse moved in roughly the same direction as the previous point\n\t\t\t\t// and replace it if so.\n\t\t\t\tconst i = ( selectionPoints.length / 3 ) - 1;\n\t\t\t\tconst i3 = i * 3;\n\t\t\t\tlet doReplace = false;\n\t\t\t\tif ( selectionPoints.length > 3 ) {\n\n\t\t\t\t\t// prev segment direction\n\t\t\t\t\ttempVec0.set( selectionPoints[ i3 - 3 ], selectionPoints[ i3 - 3 + 1 ] );\n\t\t\t\t\ttempVec1.set( selectionPoints[ i3 ], selectionPoints[ i3 + 1 ] );\n\t\t\t\t\ttempVec1.sub( tempVec0 ).normalize();\n\n\t\t\t\t\t// this segment direction\n\t\t\t\t\ttempVec0.set( selectionPoints[ i3 ], selectionPoints[ i3 + 1 ] );\n\t\t\t\t\ttempVec2.set( nx, ny );\n\t\t\t\t\ttempVec2.sub( tempVec0 ).normalize();\n\n\t\t\t\t\tconst dot = tempVec1.dot( tempVec2 );\n\t\t\t\t\tdoReplace = dot > 0.99;\n\n\t\t\t\t}\n\n\t\t\t\tif ( doReplace ) {\n\n\t\t\t\t\tselectionPoints[ i3 ] = nx;\n\t\t\t\t\tselectionPoints[ i3 + 1 ] = ny;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tselectionPoints.push( nx, ny, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tselectionShapeNeedsUpdate = true;\n\t\t\t\tselectionShape.visible = true;\n\n\t\t\t\tprevX = ex;\n\t\t\t\tprevY = ey;\n\n\t\t\t\tif ( params.liveUpdate ) {\n\n\t\t\t\t\tselectionNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n}\n\nfunction render() {\n\n\tstats.update();\n\trequestAnimationFrame( render );\n\n\tmesh.material.wireframe = params.wireframe;\n\thelper.visible = params.displayHelper;\n\n\t// Update the selection lasso lines\n\tif ( selectionShapeNeedsUpdate ) {\n\n\t\tif ( params.toolMode === 'lasso' ) {\n\n\t\t\tconst ogLength = selectionPoints.length;\n\t\t\tselectionPoints.push(\n\t\t\t\tselectionPoints[ 0 ],\n\t\t\t\tselectionPoints[ 1 ],\n\t\t\t\tselectionPoints[ 2 ]\n\t\t\t);\n\n\t\t\tselectionShape.geometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew THREE.Float32BufferAttribute( selectionPoints, 3, false )\n\t\t\t);\n\n\t\t\tselectionPoints.length = ogLength;\n\n\t\t} else {\n\n\t\t\tselectionShape.geometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew THREE.Float32BufferAttribute( selectionPoints, 3, false )\n\t\t\t);\n\n\t\t}\n\n\t\tselectionShape.frustumCulled = false;\n\t\tselectionShapeNeedsUpdate = false;\n\n\t}\n\n\tif ( selectionNeedsUpdate ) {\n\n\t\tselectionNeedsUpdate = false;\n\n\t\tif ( selectionPoints.length > 0 ) {\n\n\t\t\tupdateSelection();\n\n\t\t}\n\n\t}\n\n\tconst yScale = Math.tan( THREE.MathUtils.DEG2RAD * camera.fov / 2 ) * selectionShape.position.z;\n\tselectionShape.scale.set( - yScale * camera.aspect, - yScale, 1 );\n\n\trenderer.render( scene, camera );\n\n\tif ( params.rotate ) {\n\n\t\tgroup.rotation.y += 0.01;\n\t\tif ( params.liveUpdate && dragging ) {\n\n\t\t\tselectionNeedsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nconst invWorldMatrix = new THREE.Matrix4();\nconst camLocalPosition = new THREE.Vector3();\nconst tempRay = new THREE.Ray();\nconst centroid = new THREE.Vector3();\nconst screenCentroid = new THREE.Vector3();\nconst faceNormal = new THREE.Vector3();\nconst toScreenSpaceMatrix = new THREE.Matrix4();\nconst boxPoints = new Array( 8 ).fill().map( () => new THREE.Vector3() );\nconst boxLines = new Array( 12 ).fill().map( () => new THREE.Line3() );\nconst lassoSegments = [];\nconst perBoundsSegments = [];\nfunction updateSelection() {\n\n\t// TODO: Possible improvements\n\t// - Correctly handle the camera near clip\n\t// - Improve line line intersect performance?\n\n\ttoScreenSpaceMatrix\n\t\t.copy( mesh.matrixWorld )\n\t\t.premultiply( camera.matrixWorldInverse )\n\t\t.premultiply( camera.projectionMatrix );\n\n\t// create scratch points and lines to use for selection\n\twhile ( lassoSegments.length < selectionPoints.length ) {\n\n\t\tlassoSegments.push( new THREE.Line3() );\n\n\t}\n\n\tlassoSegments.length = selectionPoints.length;\n\n\tfor ( let s = 0, l = selectionPoints.length; s < l; s += 3 ) {\n\n\t\tconst line = lassoSegments[ s ];\n\t\tconst sNext = ( s + 3 ) % l;\n\t\tline.start.x = selectionPoints[ s ];\n\t\tline.start.y = selectionPoints[ s + 1 ];\n\n\t\tline.end.x = selectionPoints[ sNext ];\n\t\tline.end.y = selectionPoints[ sNext + 1 ];\n\n\t}\n\n\tinvWorldMatrix.copy( mesh.matrixWorld ).invert();\n\tcamLocalPosition.set( 0, 0, 0 ).applyMatrix4( camera.matrixWorld ).applyMatrix4( invWorldMatrix );\n\n\tconst startTime = window.performance.now();\n\tconst indices = [];\n\tmesh.geometry.boundsTree.shapecast( {\n\t\tintersectsBounds: ( box, isLeaf, score, depth ) => {\n\n\t\t\t// check if bounds intersect or contain the lasso region\n\t\t\tif ( ! params.useBoundsTree ) {\n\n\t\t\t\treturn INTERSECTED;\n\n\t\t\t}\n\n\t\t\t// Get the bounding box points\n\t\t\tconst { min, max } = box;\n\t\t\tlet index = 0;\n\n\t\t\tlet minY = Infinity;\n\t\t\tlet maxY = - Infinity;\n\t\t\tlet minX = Infinity;\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tconst v = boxPoints[ index ];\n\t\t\t\t\t\tv.x = x === 0 ? min.x : max.x;\n\t\t\t\t\t\tv.y = y === 0 ? min.y : max.y;\n\t\t\t\t\t\tv.z = z === 0 ? min.z : max.z;\n\t\t\t\t\t\tv.w = 1;\n\t\t\t\t\t\tv.applyMatrix4( toScreenSpaceMatrix );\n\t\t\t\t\t\tindex ++;\n\n\t\t\t\t\t\tif ( v.y < minY ) minY = v.y;\n\t\t\t\t\t\tif ( v.y > maxY ) maxY = v.y;\n\t\t\t\t\t\tif ( v.x < minX ) minX = v.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Find all the relevant segments here and cache them in the above array for\n\t\t\t// subsequent child checks to use.\n\t\t\tconst parentSegments = perBoundsSegments[ depth - 1 ] || lassoSegments;\n\t\t\tconst segmentsToCheck = perBoundsSegments[ depth ] || [];\n\t\t\tsegmentsToCheck.length = 0;\n\t\t\tperBoundsSegments[ depth ] = segmentsToCheck;\n\t\t\tfor ( let i = 0, l = parentSegments.length; i < l; i ++ ) {\n\n\t\t\t\tconst line = parentSegments[ i ];\n\t\t\t\tconst sx = line.start.x;\n\t\t\t\tconst sy = line.start.y;\n\t\t\t\tconst ex = line.end.x;\n\t\t\t\tconst ey = line.end.y;\n\t\t\t\tif ( sx < minX && ex < minX ) continue;\n\n\t\t\t\tconst startAbove = sy > maxY;\n\t\t\t\tconst endAbove = ey > maxY;\n\t\t\t\tif ( startAbove && endAbove ) continue;\n\n\t\t\t\tconst startBelow = sy < minY;\n\t\t\t\tconst endBelow = ey < minY;\n\t\t\t\tif ( startBelow && endBelow ) continue;\n\n\t\t\t\tsegmentsToCheck.push( line );\n\n\t\t\t}\n\n\t\t\tif ( segmentsToCheck.length === 0 ) {\n\n\t\t\t\treturn NOT_INTERSECTED;\n\n\t\t\t}\n\n\t\t\t// Get the screen space hull lines\n\t\t\tconst hull = getConvexHull( boxPoints );\n\t\t\tconst lines = hull.map( ( p, i ) => {\n\n\t\t\t\tconst nextP = hull[ ( i + 1 ) % hull.length ];\n\t\t\t\tconst line = boxLines[ i ];\n\t\t\t\tline.start.copy( p );\n\t\t\t\tline.end.copy( nextP );\n\t\t\t\treturn line;\n\n\t\t\t} );\n\n\t\t\t// If a lasso point is inside the hull then it's intersected and cannot be contained\n\t\t\tif ( pointRayCrossesSegments( segmentsToCheck[ 0 ].start, lines ) % 2 === 1 ) {\n\n\t\t\t\treturn INTERSECTED;\n\n\t\t\t}\n\n\t\t\t// check if the screen space hull is in the lasso\n\t\t\tlet crossings = 0;\n\t\t\tfor ( let i = 0, l = hull.length; i < l; i ++ ) {\n\n\t\t\t\tconst v = hull[ i ];\n\t\t\t\tconst pCrossings = pointRayCrossesSegments( v, segmentsToCheck );\n\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tcrossings = pCrossings;\n\n\t\t\t\t}\n\n\t\t\t\t// if two points on the hull have different amounts of crossings then\n\t\t\t\t// it can only be intersected\n\t\t\t\tif ( crossings !== pCrossings ) {\n\n\t\t\t\t\treturn INTERSECTED;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// check if there are any intersections\n\t\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\tconst boxLine = lines[ i ];\n\t\t\t\tfor ( let s = 0, ls = segmentsToCheck.length; s < ls; s ++ ) {\n\n\t\t\t\t\tif ( lineCrossesLine( boxLine, segmentsToCheck[ s ] ) ) {\n\n\t\t\t\t\t\treturn INTERSECTED;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn crossings % 2 === 0 ? NOT_INTERSECTED : CONTAINED;\n\n\t\t},\n\n\t\tintersectsTriangle: ( tri, index, contained, depth ) => {\n\n\t\t\tconst i3 = index * 3;\n\t\t\tconst a = i3 + 0;\n\t\t\tconst b = i3 + 1;\n\t\t\tconst c = i3 + 2;\n\n\t\t\t// check all the segments if using no bounds tree\n\t\t\tconst segmentsToCheck = params.useBoundsTree ? perBoundsSegments[ depth ] : lassoSegments;\n\t\t\tif ( params.selectionMode === 'centroid' || params.selectionMode === 'centroid-visible' ) {\n\n\t\t\t\t// get the center of the triangle\n\t\t\t\tcentroid.copy( tri.a ).add( tri.b ).add( tri.c ).multiplyScalar( 1 / 3 );\n\t\t\t\tscreenCentroid.copy( centroid ).applyMatrix4( toScreenSpaceMatrix );\n\n\t\t\t\t// counting the crossings\n\t\t\t\tif (\n\t\t\t\t\tcontained ||\n\t\t\t\t\tpointRayCrossesSegments( screenCentroid, segmentsToCheck ) % 2 === 1\n\t\t\t\t) {\n\n\t\t\t\t\t// if we're only selecting visible faces then perform a ray check to ensure the centroid\n\t\t\t\t\t// is visible.\n\t\t\t\t\tif ( params.selectionMode === 'centroid-visible' ) {\n\n\t\t\t\t\t\ttri.getNormal( faceNormal );\n\t\t\t\t\t\ttempRay.origin.copy( centroid ).addScaledVector( faceNormal, 1e-6 );\n\t\t\t\t\t\ttempRay.direction.subVectors( camLocalPosition, centroid );\n\n\t\t\t\t\t\tconst res = mesh.geometry.boundsTree.raycastFirst( tempRay, THREE.DoubleSide );\n\t\t\t\t\t\tif ( res ) {\n\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\treturn params.selectModel;\n\n\t\t\t\t}\n\n\t\t\t} else if ( params.selectionMode === 'intersection' ) {\n\n\t\t\t\t// if the parent bounds were marked as contained then we contain all the triangles within\n\t\t\t\tif ( contained ) {\n\n\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\treturn params.selectModel;\n\n\t\t\t\t}\n\n\t\t\t\t// get the projected vertices\n\t\t\t\tconst vertices = [\n\t\t\t\t\ttri.a,\n\t\t\t\t\ttri.b,\n\t\t\t\t\ttri.c,\n\t\t\t\t];\n\n\t\t\t\t// check if any of the vertices are inside the selection and if so then the triangle is selected\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tconst v = vertices[ j ];\n\t\t\t\t\tv.applyMatrix4( toScreenSpaceMatrix );\n\n\t\t\t\t\tconst crossings = pointRayCrossesSegments( v, segmentsToCheck );\n\t\t\t\t\tif ( crossings % 2 === 1 ) {\n\n\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\treturn params.selectModel;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// get the lines for the triangle\n\t\t\t\tconst lines = [\n\t\t\t\t\tboxLines[ 0 ],\n\t\t\t\t\tboxLines[ 1 ],\n\t\t\t\t\tboxLines[ 2 ],\n\t\t\t\t];\n\n\t\t\t\tlines[ 0 ].start.copy( tri.a );\n\t\t\t\tlines[ 0 ].end.copy( tri.b );\n\n\t\t\t\tlines[ 1 ].start.copy( tri.b );\n\t\t\t\tlines[ 1 ].end.copy( tri.c );\n\n\t\t\t\tlines[ 2 ].start.copy( tri.c );\n\t\t\t\tlines[ 2 ].end.copy( tri.a );\n\n\t\t\t\t// check for the case where a selection intersects a triangle but does not contain any\n\t\t\t\t// of the vertices\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst l = lines[ i ];\n\t\t\t\t\tfor ( let s = 0, sl = segmentsToCheck.length; s < sl; s ++ ) {\n\n\t\t\t\t\t\tif ( lineCrossesLine( l, segmentsToCheck[ s ] ) ) {\n\n\t\t\t\t\t\t\tindices.push( a, b, c );\n\t\t\t\t\t\t\treturn params.selectModel;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t} );\n\n\tconst traverseTime = window.performance.now() - startTime;\n\toutputContainer.innerText = `${ traverseTime.toFixed( 3 ) }ms`;\n\n\tconst indexAttr = mesh.geometry.index;\n\tconst newIndexAttr = highlightMesh.geometry.index;\n\tif ( indices.length && params.selectModel ) {\n\n\t\t// if we found indices and we want to select the whole model\n\t\tfor ( let i = 0, l = indexAttr.count; i < l; i ++ ) {\n\n\t\t\tconst i2 = indexAttr.getX( i );\n\t\t\tnewIndexAttr.setX( i, i2 );\n\n\t\t}\n\n\t\thighlightMesh.geometry.drawRange.count = Infinity;\n\t\tnewIndexAttr.needsUpdate = true;\n\n\t} else {\n\n\t\t// update the highlight mesh\n\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tconst i2 = indexAttr.getX( indices[ i ] );\n\t\t\tnewIndexAttr.setX( i, i2 );\n\n\t\t}\n\n\t\thighlightMesh.geometry.drawRange.count = indices.length;\n\t\tnewIndexAttr.needsUpdate = true;\n\n\t}\n\n}\n\n// Math Functions\n// https://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/\nfunction getConvexHull( points ) {\n\n\tfunction orientation( p, q, r ) {\n\n\t\tconst val =\n\t\t\t( q.y - p.y ) * ( r.x - q.x ) -\n\t\t\t( q.x - p.x ) * ( r.y - q.y );\n\n\t\tif ( val == 0 ) {\n\n\t\t\treturn 0; // colinear\n\n\t\t}\n\n\t\t// clockwise or counterclockwise\n\t\treturn ( val > 0 ) ? 1 : 2;\n\n\t}\n\n\tfunction distSq( p1, p2 ) {\n\n\t\treturn ( p1.x - p2.x ) * ( p1.x - p2.x ) +\n\t\t\t( p1.y - p2.y ) * ( p1.y - p2.y );\n\n\t}\n\n\tfunction compare( p1, p2 ) {\n\n\t   // Find orientation\n\t   const o = orientation( p0, p1, p2 );\n\t   if ( o == 0 )\n\t\t return ( distSq( p0, p2 ) >= distSq( p0, p1 ) ) ? - 1 : 1;\n\n\t   return ( o == 2 ) ? - 1 : 1;\n\n\t}\n\n\t// find the lowest point in 2d\n\tlet lowestY = Infinity;\n\tlet lowestIndex = - 1;\n\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\tconst p = points[ i ];\n\t\tif ( p.y < lowestY ) {\n\n\t\t\tlowestIndex = i;\n\t\t\tlowestY = p.y;\n\n\t\t}\n\n\t}\n\n\t// sort the points\n\tconst p0 = points[ lowestIndex ];\n\tpoints[ lowestIndex ] = points[ 0 ];\n\tpoints[ 0 ] = p0;\n\n\tpoints = points.sort( compare );\n\n\t// filter the points\n\tlet m = 1;\n\tconst n = points.length;\n\tfor ( let i = 1; i < n; i ++ ) {\n\n\t\twhile ( i < n - 1 && orientation( p0, points[ i ], points[ i + 1 ] ) == 0 ) {\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\tpoints[ m ] = points[ i ];\n\t\tm ++;\n\n\t}\n\n\t// early out if we don't have enough points for a hull\n\tif ( m < 3 ) return null;\n\n\t// generate the hull\n\tconst hull = [ points[ 0 ], points[ 1 ], points[ 2 ] ];\n\tfor ( let i = 3; i < m; i ++ ) {\n\n\t\twhile ( orientation( hull[ hull.length - 2 ], hull[ hull.length - 1 ], points[ i ] ) !== 2 ) {\n\n\t\t\thull.pop();\n\n\t\t}\n\n\t\thull.push( points[ i ] );\n\n\t}\n\n\treturn hull;\n\n}\n\nfunction pointRayCrossesLine( point, line, prevDirection, thisDirection ) {\n\n\tconst { start, end } = line;\n\tconst px = point.x;\n\tconst py = point.y;\n\n\tconst sy = start.y;\n\tconst ey = end.y;\n\n\tif ( sy === ey ) return false;\n\n\tif ( py > sy && py > ey ) return false; // above\n\tif ( py < sy && py < ey ) return false; // below\n\n\tconst sx = start.x;\n\tconst ex = end.x;\n\tif ( px > sx && px > ex ) return false; // right\n\tif ( px < sx && px < ex ) { // left\n\n\t\tif ( py === sy && prevDirection !== thisDirection ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t// check the side\n\tconst dx = ex - sx;\n\tconst dy = ey - sy;\n\tconst perpx = dy;\n\tconst perpy = - dx;\n\n\tconst pdx = px - sx;\n\tconst pdy = py - sy;\n\n\tconst dot = perpx * pdx + perpy * pdy;\n\n\tif ( Math.sign( dot ) !== Math.sign( perpx ) ) {\n\n\t\treturn true;\n\n\t}\n\n\treturn false;\n\n}\n\nfunction pointRayCrossesSegments( point, segments ) {\n\n\tlet crossings = 0;\n\tconst firstSeg = segments[ segments.length - 1 ];\n\tlet prevDirection = firstSeg.start.y > firstSeg.end.y;\n\tfor ( let s = 0, l = segments.length; s < l; s ++ ) {\n\n\t\tconst line = segments[ s ];\n\t\tconst thisDirection = line.start.y > line.end.y;\n\t\tif ( pointRayCrossesLine( point, line, prevDirection, thisDirection ) ) {\n\n\t\t\tcrossings ++;\n\n\t\t}\n\n\t\tprevDirection = thisDirection;\n\n\t}\n\n\treturn crossings;\n\n}\n\n// https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect\nfunction lineCrossesLine( l1, l2 ) {\n\n\tfunction ccw( A, B, C ) {\n\n\t\treturn ( C.y - A.y ) * ( B.x - A.x ) > ( B.y - A.y ) * ( C.x - A.x );\n\n\t}\n\n\tconst A = l1.start;\n\tconst B = l1.end;\n\n\tconst C = l2.start;\n\tconst D = l2.end;\n\n\treturn ccw( A, C, D ) !== ccw( B, C, D ) && ccw( A, B, C ) !== ccw( A, B, D );\n\n}\n"],"names":["f","e","$8d6448069697305c$exports","a","c","appendChild","dom","u","d","children","length","style","display","l","document","createElement","cssText","addEventListener","preventDefault","k","performance","Date","now","g","r","Panel","h","self","memory","t","REVISION","addPanel","showPanel","begin","end","update","usedJSHeapSize","jsHeapSizeLimit","this","domElement","setMode","Infinity","Math","round","window","devicePixelRatio","v","m","n","p","q","width","height","b","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","w","min","max","drawImage","define","amd","Stats","$cdfe6782841c53e7$var$params","toolMode","selectionMode","liveUpdate","selectModel","wireframe","useBoundsTree","displayHelper","helperDepth","rotate","$cdfe6782841c53e7$var$renderer","$cdfe6782841c53e7$var$camera","$cdfe6782841c53e7$var$scene","$cdfe6782841c53e7$var$gui","$cdfe6782841c53e7$var$stats","$cdfe6782841c53e7$var$controls","$cdfe6782841c53e7$var$selectionShape","$cdfe6782841c53e7$var$mesh","$cdfe6782841c53e7$var$helper","$cdfe6782841c53e7$var$highlightMesh","$cdfe6782841c53e7$var$highlightWireframeMesh","$cdfe6782841c53e7$var$outputContainer","$cdfe6782841c53e7$var$group","$cdfe6782841c53e7$var$selectionPoints","$cdfe6782841c53e7$var$dragging","$cdfe6782841c53e7$var$selectionShapeNeedsUpdate","$cdfe6782841c53e7$var$selectionNeedsUpdate","getElementById","bgColor","$ilwiq","Color","WebGLRenderer","antialias","setPixelRatio","setSize","innerWidth","innerHeight","setClearColor","shadowMap","enabled","outputEncoding","sRGBEncoding","body","Scene","light","DirectionalLight","castShadow","shadow","mapSize","set","position","add","AmbientLight","PerspectiveCamera","far","updateProjectionMatrix","Line","material","color","convertSRGBToLinear","renderOrder","z","depthTest","scale","setScalar","Group","Mesh","TorusKnotGeometry","toNonIndexed","MeshStandardMaterial","polygonOffset","polygonOffsetFactor","geometry","boundsTree","$4CEV9","MeshBVH","setAttribute","Uint8BufferAttribute","Array","index","count","fill","receiveShadow","MeshBVHVisualizer","clone","drawRange","MeshBasicMaterial","opacity","transparent","depthWrite","copy","gridHelper","GridHelper","y","shadowPlane","PlaneBufferGeometry","ShadowMaterial","rotation","x","PI","$parcel$interopDefault","$5Rd1x","OrbitControls","minDistance","touches","ONE","TOUCH","PAN","mouseButtons","LEFT","MOUSE","TWO","ROTATE","RIGHT","enablePan","$jiuw3","GUI","selectionFolder","addFolder","open","displayFolder","onChange","depth","startX","startY","prevX","prevY","tempVec0","Vector2","tempVec1","tempVec2","clientX","clientY","visible","buttons","ex","ey","nx","ny","abs","i3","doReplace","sub","normalize","dot","push","aspect","$cdfe6782841c53e7$var$init","$cdfe6782841c53e7$var$render","requestAnimationFrame","ogLength","Float32BufferAttribute","frustumCulled","$cdfe6782841c53e7$var$toScreenSpaceMatrix","matrixWorld","premultiply","matrixWorldInverse","projectionMatrix","$cdfe6782841c53e7$var$lassoSegments","Line3","s","line","sNext","start","$cdfe6782841c53e7$var$invWorldMatrix","invert","$cdfe6782841c53e7$var$camLocalPosition","applyMatrix4","startTime","indices","shapecast","intersectsBounds","box","isLeaf","score","INTERSECTED","minY","maxY","minX","$cdfe6782841c53e7$var$boxPoints","parentSegments","$cdfe6782841c53e7$var$perBoundsSegments","segmentsToCheck","i","sx","sy","endAbove","endBelow","NOT_INTERSECTED","hull","points","orientation","val","distSq","p1","p2","compare","o","p0","lowestY","lowestIndex","sort","i1","i2","pop","$cdfe6782841c53e7$var$getConvexHull","lines","map","nextP","$cdfe6782841c53e7$var$boxLines","$cdfe6782841c53e7$var$pointRayCrossesSegments","crossings","l1","pCrossings","l2","boxLine","ls","$cdfe6782841c53e7$var$lineCrossesLine","CONTAINED","intersectsTriangle","tri","contained","$cdfe6782841c53e7$var$centroid","multiplyScalar","$cdfe6782841c53e7$var$screenCentroid","getNormal","$cdfe6782841c53e7$var$faceNormal","$cdfe6782841c53e7$var$tempRay","origin","addScaledVector","direction","subVectors","raycastFirst","DoubleSide","vertices","j","sl","traverseTime","innerText","toFixed","indexAttr","newIndexAttr","getX","setX","needsUpdate","$cdfe6782841c53e7$var$updateSelection","yScale","tan","MathUtils","DEG2RAD","fov","render","Matrix4","Vector3","Ray","$cdfe6782841c53e7$var$pointRayCrossesLine","point","prevDirection","thisDirection","px","py","perpx","sign","segments","firstSeg","ccw","A","B","C","D"],"version":3,"file":"selection.2c682e6d.js.map"}