{"mappings":"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","sources":["node_modules/@parcel/runtime-js/lib/runtime-cd0c14bcc7d3a931.js","node_modules/stats.js/build/stats.min.js","example/utils/GenerateSDFMaterial.js","example/utils/RenderSDFLayerMaterial.js","example/utils/RayMarchSDFMaterial.js","example/sdfGeneration.js"],"sourcesContent":["require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"1WzX2\\\":\\\"sdfGeneration.3e4cbe3a.js\\\",\\\"b4BBl\\\":\\\"generateAsync.worker.5bf93d10.js\\\",\\\"9JIya\\\":\\\"asyncGenerate.924881df.js\\\",\\\"1o4q0\\\":\\\"characterMovement.00d7d3c9.js\\\",\\\"bEy7u\\\":\\\"asyncGenerate.6b6e94f2.js\\\",\\\"atdpM\\\":\\\"characterMovement.64910e00.js\\\",\\\"7RGMC\\\":\\\"characterMovement.9329e59d.js\\\",\\\"efnpd\\\":\\\"cpuPathTracing.c866b4cf.js\\\",\\\"817sr\\\":\\\"asyncGenerate.4d3a79b0.js\\\",\\\"fI6hf\\\":\\\"clippedEdges.c7f3e0bd.js\\\"}\"));","// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){\"object\"===typeof exports&&\"undefined\"!==typeof module?module.exports=e():\"function\"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel(\"FPS\",\"#0ff\",\"#002\")),h=e(new f.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var t=e(new f.Panel(\"MB\",\"#f08\",\"#201\"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=h;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+\" \"+e+\" (\"+g(c)+\"-\"+g(k)+\")\",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n","import { ShaderMaterial, Matrix4 } from 'three';\nimport { shaderIntersectFunction, shaderDistanceFunction, shaderStructs, MeshBVHUniformStruct } from '../..';\n\nexport class GenerateSDFMaterial extends ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\n\t\t\t\tmatrix: { value: new Matrix4() },\n\t\t\t\tzValue: { value: 0 },\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\n\t\t\t\t${ shaderStructs }\n\t\t\t\t${ shaderIntersectFunction }\n\t\t\t\t${ shaderDistanceFunction }\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform float zValue;\n\t\t\t\tuniform mat4 matrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// compute the point in space to check\n\t\t\t\t\tvec3 point = vec3( vUv, zValue );\n\t\t\t\t\tpoint -= vec3( 0.5 );\n\t\t\t\t\tpoint = ( matrix * vec4( point, 1.0 ) ).xyz;\n\n\t\t\t\t\t// retrieve the distance and other values\n\t\t\t\t\tuvec4 faceIndices;\n\t\t\t\t\tvec3 faceNormal;\n\t\t\t\t\tvec3 barycoord;\n\t\t\t\t\tfloat side;\n\t\t\t\t\tvec3 outPoint;\n\t\t\t\t\tfloat dist = bvhClosestPointToPoint( bvh, point.xyz, faceIndices, faceNormal, barycoord, side, outPoint );\n\n\t\t\t\t\t// if the triangle side is the back then it must be on the inside and the value negative\n\t\t\t\t\tgl_FragColor = vec4( side * dist, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import { ShaderMaterial } from 'three';\n\nexport class RenderSDFLayerMaterial extends ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tdefines: {\n\n\t\t\t\tDISPLAY_GRID: 0,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tsdfTex: { value: null },\n\t\t\t\tlayer: { value: 0 },\n\t\t\t\tlayers: { value: 0 },\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler3D sdfTex;\n\t\t\t\tuniform float layer;\n\t\t\t\tuniform float layers;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#if DISPLAY_GRID\n\n\t\t\t\t\tfloat dim = ceil( sqrt( layers ) );\n\t\t\t\t\tvec2 cell = floor( vUv * dim );\n\t\t\t\t\tvec2 frac = vUv * dim - cell;\n\t\t\t\t\tfloat zLayer = ( cell.y * dim + cell.x ) / ( dim * dim );\n\n\t\t\t\t\tfloat dist = texture( sdfTex, vec3( frac, zLayer ) ).r;\n\t\t\t\t\tgl_FragColor.rgb = dist > 0.0 ? vec3( 0, dist, 0 ) : vec3( - dist, 0, 0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#else\n\n\t\t\t\t\tfloat dist = texture( sdfTex, vec3( vUv, layer ) ).r;\n\t\t\t\t\tgl_FragColor.rgb = dist > 0.0 ? vec3( 0, dist, 0 ) : vec3( - dist, 0, 0 );\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import { ShaderMaterial, Matrix4, Vector3 } from 'three';\n\nexport class RayMarchSDFMaterial extends ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tdefines: {\n\n\t\t\t\tMAX_STEPS: 500,\n\t\t\t\tSURFACE_EPSILON: 0.001,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tsurface: { value: 0 },\n\t\t\t\tsdfTex: { value: null },\n\t\t\t\tnormalStep: { value: new Vector3() },\n\t\t\t\tprojectionInverse: { value: new Matrix4() },\n\t\t\t\tsdfTransformInverse: { value: new Matrix4() }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform float surface;\n\t\t\t\tuniform sampler3D sdfTex;\n\t\t\t\tuniform vec3 normalStep;\n\t\t\t\tuniform mat4 projectionInverse;\n\t\t\t\tuniform mat4 sdfTransformInverse;\n\n\t\t\t\t#include <common>\n\n\t\t\t\t// distance to box bounds\n\t\t\t\tvec2 rayBoxDist( vec3 boundsMin, vec3 boundsMax, vec3 rayOrigin, vec3 rayDir ) {\n\n\t\t\t\t\tvec3 t0 = ( boundsMin - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 t1 = ( boundsMax - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 tmin = min( t0, t1 );\n\t\t\t\t\tvec3 tmax = max( t0, t1 );\n\n\t\t\t\t\tfloat distA = max( max( tmin.x, tmin.y ), tmin.z );\n\t\t\t\t\tfloat distB = min( tmax.x, min( tmax.y, tmax.z ) );\n\n\t\t\t\t\tfloat distToBox = max( 0.0, distA );\n\t\t\t\t\tfloat distInsideBox = max( 0.0, distB - distToBox );\n\t\t\t\t\treturn vec2( distToBox, distInsideBox );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// get the inverse of the sdf box transform\n\t\t\t\t\tmat4 sdfTransform = inverse( sdfTransformInverse );\n\n\t\t\t\t\t// convert the uv to clip space for ray transformation\n\t\t\t\t\tvec2 clipSpace = 2.0 * vUv - vec2( 1.0 );\n\n\t\t\t\t\t// get world ray direction\n\t\t\t\t\tvec3 rayOrigin = vec3( 0.0 );\n\t\t\t\t\tvec4 homogenousDirection = projectionInverse * vec4( clipSpace, - 1.0, 1.0 );\n\t\t\t\t\tvec3 rayDirection = normalize( homogenousDirection.xyz / homogenousDirection.w );\n\n\t\t\t\t\t// transform ray into local coordinates of sdf bounds\n\t\t\t\t\tvec3 sdfRayOrigin = ( sdfTransformInverse * vec4( rayOrigin, 1.0 ) ).xyz;\n\t\t\t\t\tvec3 sdfRayDirection = normalize( ( sdfTransformInverse * vec4( rayDirection, 0.0 ) ).xyz );\n\n\t\t\t\t\t// find whether our ray hits the box bounds in the local box space\n\t\t\t\t\tvec2 boxIntersectionInfo = rayBoxDist( vec3( - 0.5 ), vec3( 0.5 ), sdfRayOrigin, sdfRayDirection );\n\t\t\t\t\tfloat distToBox = boxIntersectionInfo.x;\n\t\t\t\t\tfloat distInsideBox = boxIntersectionInfo.y;\n\t\t\t\t\tbool intersectsBox = distInsideBox > 0.0;\n\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\tif ( intersectsBox ) {\n\n\t\t\t\t\t\t// find the surface point in world space\n\t\t\t\t\t\tbool intersectsSurface = false;\n\t\t\t\t\t\tvec4 localPoint = vec4( sdfRayOrigin + sdfRayDirection * ( distToBox + 1e-5 ), 1.0 );\n\t\t\t\t\t\tvec4 point = sdfTransform * localPoint;\n\n\t\t\t\t\t\t// ray march\n\t\t\t\t\t\tfor ( int i = 0; i < MAX_STEPS; i ++ ) {\n\n\t\t\t\t\t\t\t// sdf box extends from - 0.5 to 0.5\n\t\t\t\t\t\t\t// transform into the local bounds space [ 0, 1 ] and check if we're inside the bounds\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tif ( uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || uv.z < 0.0 || uv.z > 1.0 ) {\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// get the distance to surface and exit the loop if we're close to the surface\n\t\t\t\t\t\t\tfloat distanceToSurface = texture2D( sdfTex, uv ).r - surface;\n\t\t\t\t\t\t\tif ( distanceToSurface < SURFACE_EPSILON ) {\n\n\t\t\t\t\t\t\t\tintersectsSurface = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// step the ray\n\t\t\t\t\t\t\tpoint.xyz += rayDirection * abs( distanceToSurface );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the surface normal\n\t\t\t\t\t\tif ( intersectsSurface ) {\n\n\t\t\t\t\t\t\t// compute the surface normal\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tfloat dx = texture( sdfTex, uv + vec3( normalStep.x, 0.0, 0.0 ) ).r - texture( sdfTex, uv - vec3( normalStep.x, 0.0, 0.0 ) ).r;\n\t\t\t\t\t\t\tfloat dy = texture( sdfTex, uv + vec3( 0.0, normalStep.y, 0.0 ) ).r - texture( sdfTex, uv - vec3( 0.0, normalStep.y, 0.0 ) ).r;\n\t\t\t\t\t\t\tfloat dz = texture( sdfTex, uv + vec3( 0.0, 0.0, normalStep.z ) ).r - texture( sdfTex, uv - vec3( 0.0, 0.0, normalStep.z ) ).r;\n\t\t\t\t\t\t\tvec3 normal = normalize( vec3( dx, dy, dz ) );\n\n\t\t\t\t\t\t\t// compute some basic lighting effects\n\t\t\t\t\t\t\tvec3 lightDirection = normalize( vec3( 1.0 ) );\n\t\t\t\t\t\t\tfloat lightIntensity =\n\t\t\t\t\t\t\t\tsaturate( dot( normal, lightDirection ) ) +\n\t\t\t\t\t\t\t\tsaturate( dot( normal, - lightDirection ) ) * 0.05 +\n\t\t\t\t\t\t\t\t0.1;\n\t\t\t\t\t\t\tgl_FragColor.rgb = vec3( lightIntensity );\n\t\t\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport Stats from 'stats.js';\nimport { GenerateMeshBVHWorker } from '../src/workers/GenerateMeshBVHWorker.js';\nimport { StaticGeometryGenerator } from '..';\nimport { GenerateSDFMaterial } from './utils/GenerateSDFMaterial.js';\nimport { RenderSDFLayerMaterial } from './utils/RenderSDFLayerMaterial.js';\nimport { RayMarchSDFMaterial } from './utils/RayMarchSDFMaterial.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\n\nconst params = {\n\n\tgpuGeneration: true,\n\tresolution: 75,\n\tmargin: 0.2,\n\tregenerate: () => updateSDF(),\n\n\tmode: 'raymarching',\n\tlayer: 0,\n\tsurface: 0.1,\n\n};\n\nlet renderer, camera, scene, gui, stats, boxHelper;\nlet outputContainer, bvh, geometry, sdfTex, mesh;\nlet generateSdfPass, layerPass, raymarchPass;\nlet bvhGenerationWorker;\nconst inverseBoundsMatrix = new THREE.Matrix4();\n\ninit();\nrender();\n\nfunction init() {\n\n\toutputContainer = document.getElementById( 'output' );\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer( { antialias: true } );\n\trenderer.setPixelRatio( window.devicePixelRatio );\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\trenderer.setClearColor( 0, 0 );\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\tdocument.body.appendChild( renderer.domElement );\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\n\tconst light = new THREE.DirectionalLight( 0xffffff, 1 );\n\tlight.position.set( 1, 1, 1 );\n\tscene.add( light );\n\tscene.add( new THREE.AmbientLight( 0xffffff, 0.2 ) );\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 50 );\n\tcamera.position.set( 1, 1, 2 );\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\n\tboxHelper = new THREE.Box3Helper( new THREE.Box3() );\n\tscene.add( boxHelper );\n\n\tnew OrbitControls( camera, renderer.domElement );\n\n\t// stats setup\n\tstats = new Stats();\n\tdocument.body.appendChild( stats.dom );\n\n\t// sdf pass to generate the 3d texture\n\tgenerateSdfPass = new FullScreenQuad( new GenerateSDFMaterial() );\n\n\t// screen pass to render a single layer of the 3d texture\n\tlayerPass = new FullScreenQuad( new RenderSDFLayerMaterial() );\n\n\t// screen pass to render the sdf ray marching\n\traymarchPass = new FullScreenQuad( new RayMarchSDFMaterial() );\n\n\t// load model and generate bvh\n\tbvhGenerationWorker = new GenerateMeshBVHWorker();\n\n\tnew GLTFLoader()\n\t\t.setMeshoptDecoder( MeshoptDecoder )\n\t\t.loadAsync( 'https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/stanford-bunny/bunny.glb' )\n\t\t.then( gltf => {\n\n\t\t\tgltf.scene.updateMatrixWorld( true );\n\n\t\t\tconst staticGen = new StaticGeometryGenerator( gltf.scene );\n\t\t\tstaticGen.attributes = [ 'position', 'normal' ];\n\t\t\tstaticGen.useGroups = false;\n\n\t\t\tgeometry = staticGen.generate().center();\n\n\t\t\treturn bvhGenerationWorker.generate( geometry, { maxLeafTris: 1 } );\n\n\t\t} )\n\t\t.then( result => {\n\n\t\t\tbvh = result;\n\n\t\t\tmesh = new THREE.Mesh( geometry, new THREE.MeshStandardMaterial() );\n\t\t\tscene.add( mesh );\n\n\t\t\tupdateSDF();\n\n\t\t} );\n\n\trebuildGUI();\n\n\twindow.addEventListener( 'resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\t}, false );\n\n}\n\n// build the gui with parameters based on the selected display mode\nfunction rebuildGUI() {\n\n\tif ( gui ) {\n\n\t\tgui.destroy();\n\n\t}\n\n\tparams.layer = Math.min( params.resolution, params.layer );\n\n\tgui = new GUI();\n\n\tconst generationFolder = gui.addFolder( 'generation' );\n\tgenerationFolder.add( params, 'gpuGeneration' );\n\tgenerationFolder.add( params, 'resolution', 10, 200, 1 );\n\tgenerationFolder.add( params, 'margin', 0, 1 );\n\tgenerationFolder.add( params, 'regenerate' );\n\n\tconst displayFolder = gui.addFolder( 'display' );\n\tdisplayFolder.add( params, 'mode', [ 'geometry', 'raymarching', 'layer', 'grid layers' ] ).onChange( () => {\n\n\t\trebuildGUI();\n\n\t} );\n\n\tif ( params.mode === 'layer' ) {\n\n\t\tdisplayFolder.add( params, 'layer', 0, params.resolution, 1 );\n\n\t}\n\n\tif ( params.mode === 'raymarching' ) {\n\n\t\tdisplayFolder.add( params, 'surface', - 0.2, 0.5 );\n\n\t}\n\n}\n\n// update the sdf texture based on the selected parameters\nfunction updateSDF() {\n\n\tconst dim = params.resolution;\n\tconst matrix = new THREE.Matrix4();\n\tconst center = new THREE.Vector3();\n\tconst quat = new THREE.Quaternion();\n\tconst scale = new THREE.Vector3();\n\n\t// compute the bounding box of the geometry including the margin which is used to\n\t// define the range of the SDF\n\tgeometry.boundingBox.getCenter( center );\n\tscale.subVectors( geometry.boundingBox.max, geometry.boundingBox.min );\n\tscale.x += 2 * params.margin;\n\tscale.y += 2 * params.margin;\n\tscale.z += 2 * params.margin;\n\tmatrix.compose( center, quat, scale );\n\tinverseBoundsMatrix.copy( matrix ).invert();\n\n\t// update the box helper\n\tboxHelper.box.copy( geometry.boundingBox );\n\tboxHelper.box.min.x -= params.margin;\n\tboxHelper.box.min.y -= params.margin;\n\tboxHelper.box.min.z -= params.margin;\n\tboxHelper.box.max.x += params.margin;\n\tboxHelper.box.max.y += params.margin;\n\tboxHelper.box.max.z += params.margin;\n\n\t// dispose of the existing sdf\n\tif ( sdfTex ) {\n\n\t\tsdfTex.dispose();\n\n\t}\n\n\tconst pxWidth = 1 / dim;\n\tconst halfWidth = 0.5 * pxWidth;\n\n\tconst startTime = window.performance.now();\n\tif ( params.gpuGeneration ) {\n\n\t\t// create a new 3d render target texture\n\t\tsdfTex = new THREE.WebGL3DRenderTarget( dim, dim, dim );\n\t\tsdfTex.texture.format = THREE.RedFormat;\n\t\tsdfTex.texture.type = THREE.FloatType;\n\t\tsdfTex.texture.minFilter = THREE.LinearFilter;\n\t\tsdfTex.texture.magFilter = THREE.LinearFilter;\n\n\t\t// prep the sdf generation material pass\n\t\tgenerateSdfPass.material.uniforms.bvh.value.updateFrom( bvh );\n\t\tgenerateSdfPass.material.uniforms.matrix.value.copy( matrix );\n\n\t\t// render into each layer\n\t\tfor ( let i = 0; i < dim; i ++ ) {\n\n\t\t\tgenerateSdfPass.material.uniforms.zValue.value = i * pxWidth + halfWidth;\n\n\t\t\trenderer.setRenderTarget( sdfTex, i );\n\t\t\tgenerateSdfPass.render( renderer );\n\n\t\t}\n\n\t\t// initiate read back to get a rough estimate of time taken to generate the sdf\n\t\trenderer.readRenderTargetPixels( sdfTex, 0, 0, 1, 1, new Float32Array( 4 ) );\n\t\trenderer.setRenderTarget( null );\n\n\t} else {\n\n\t\t// create a new 3d data texture\n\t\tsdfTex = new THREE.Data3DTexture( new Float32Array( dim ** 3 ), dim, dim, dim );\n\t\tsdfTex.format = THREE.RedFormat;\n\t\tsdfTex.type = THREE.FloatType;\n\t\tsdfTex.minFilter = THREE.LinearFilter;\n\t\tsdfTex.magFilter = THREE.LinearFilter;\n\t\tsdfTex.needsUpdate = true;\n\n\t\tconst posAttr = geometry.attributes.position;\n\t\tconst indexAttr = geometry.index;\n\t\tconst point = new THREE.Vector3();\n\t\tconst normal = new THREE.Vector3();\n\t\tconst delta = new THREE.Vector3();\n\t\tconst tri = new THREE.Triangle();\n\t\tconst target = {};\n\n\t\t// iterate over all pixels and check distance\n\t\tfor ( let x = 0; x < dim; x ++ ) {\n\n\t\t\tfor ( let y = 0; y < dim; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z < dim; z ++ ) {\n\n\t\t\t\t\t// adjust by half width of the pixel so we sample the pixel center\n\t\t\t\t\t// and offset by half the box size.\n\t\t\t\t\tpoint.set(\n\t\t\t\t\t\thalfWidth + x * pxWidth - 0.5,\n\t\t\t\t\t\thalfWidth + y * pxWidth - 0.5,\n\t\t\t\t\t\thalfWidth + z * pxWidth - 0.5,\n\t\t\t\t\t).applyMatrix4( matrix );\n\n\t\t\t\t\tconst index = x + y * dim + z * dim * dim;\n\t\t\t\t\tconst dist = bvh.closestPointToPoint( point, target ).distance;\n\n\t\t\t\t\t// get the face normal to determine if the distance should be positive or negative\n\t\t\t\t\tconst faceIndex = target.faceIndex;\n\t\t\t\t\tconst i0 = indexAttr.getX( faceIndex * 3 + 0 );\n\t\t\t\t\tconst i1 = indexAttr.getX( faceIndex * 3 + 1 );\n\t\t\t\t\tconst i2 = indexAttr.getX( faceIndex * 3 + 2 );\n\t\t\t\t\ttri.setFromAttributeAndIndices( posAttr, i0, i1, i2 );\n\t\t\t\t\ttri.getNormal( normal );\n\t\t\t\t\tdelta.subVectors( target.point, point );\n\n\t\t\t\t\t// set the distance in the texture data\n\t\t\t\t\tsdfTex.image.data[ index ] = normal.dot( delta ) > 0.0 ? - dist : dist;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// update the timing display\n\tconst delta = window.performance.now() - startTime;\n\toutputContainer.innerText = `${ delta.toFixed( 2 ) }ms`;\n\n\trebuildGUI();\n\n}\n\nfunction render() {\n\n\tstats.update();\n\trequestAnimationFrame( render );\n\n\tif ( ! sdfTex ) {\n\n\t\t// render nothing\n\t\treturn;\n\n\t} else if ( params.mode === 'geometry' ) {\n\n\t\t// render the rasterized geometry\n\t\trenderer.render( scene, camera );\n\n\t} else if ( params.mode === 'layer' || params.mode === 'grid layers' ) {\n\n\t\t// render a layer of the 3d texture\n\t\tlet tex;\n\t\tconst material = layerPass.material;\n\t\tif ( sdfTex.isData3DTexture ) {\n\n\t\t\tmaterial.uniforms.layer.value = params.layer / sdfTex.image.width;\n\t\t\tmaterial.uniforms.sdfTex.value = sdfTex;\n\t\t\ttex = sdfTex;\n\n\t\t} else {\n\n\t\t\tmaterial.uniforms.layer.value = params.layer / sdfTex.width;\n\t\t\tmaterial.uniforms.sdfTex.value = sdfTex.texture;\n\t\t\ttex = sdfTex.texture;\n\n\t\t}\n\n\t\tmaterial.uniforms.layers.value = tex.image.width;\n\n\t\tconst gridMode = params.mode === 'layer' ? 0 : 1;\n\t\tif ( gridMode !== material.defines.DISPLAY_GRID ) {\n\n\t\t\tmaterial.defines.DISPLAY_GRID = gridMode;\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tlayerPass.render( renderer );\n\n\t} else if ( params.mode === 'raymarching' ) {\n\n\t\t// render the ray marched texture\n\t\tcamera.updateMatrixWorld();\n\t\tmesh.updateMatrixWorld();\n\n\t\tlet tex;\n\t\tif ( sdfTex.isData3DTexture ) {\n\n\t\t\ttex = sdfTex;\n\n\t\t} else {\n\n\t\t\ttex = sdfTex.texture;\n\n\t\t}\n\n\t\tconst { width, depth, height } = tex.image;\n\t\traymarchPass.material.uniforms.sdfTex.value = tex;\n\t\traymarchPass.material.uniforms.normalStep.value.set( 1 / width, 1 / height, 1 / depth );\n\t\traymarchPass.material.uniforms.surface.value = params.surface;\n\t\traymarchPass.material.uniforms.projectionInverse.value.copy( camera.projectionMatrixInverse );\n\t\traymarchPass.material.uniforms.sdfTransformInverse.value.copy( mesh.matrixWorld ).invert().premultiply( inverseBoundsMatrix ).multiply( camera.matrixWorld );\n\t\traymarchPass.render( renderer );\n\n\t}\n\n}\n"],"names":["parcelRequire","register","JSON","parse","f","e","$8d6448069697305c$exports","a","c","appendChild","dom","u","d","children","length","style","display","l","document","createElement","cssText","addEventListener","preventDefault","k","performance","Date","now","g","r","Panel","h","self","memory","t","REVISION","addPanel","showPanel","begin","end","update","usedJSHeapSize","jsHeapSizeLimit","this","domElement","setMode","Infinity","Math","round","window","devicePixelRatio","v","m","n","p","q","width","height","b","getContext","font","textBaseline","fillStyle","fillRect","fillText","globalAlpha","w","min","max","drawImage","define","amd","Stats","$445e06dac1d69dea$export$89d8017d8280911a","$ilwiq","ShaderMaterial","params","super","uniforms","matrix","value","Matrix4","zValue","bvh","$4CEV9","MeshBVHUniformStruct","vertexShader","$2ff529b7be002585$export$9fb7e1e81432db6c","defines","DISPLAY_GRID","sdfTex","layer","layers","$2f2ddb336b460d2c$export$7518dfdc666d2802","MAX_STEPS","SURFACE_EPSILON","surface","normalStep","Vector3","projectionInverse","sdfTransformInverse","$c345b227375090f6$var$params","gpuGeneration","resolution","margin","regenerate","$c345b227375090f6$var$updateSDF","mode","$c345b227375090f6$var$renderer","$c345b227375090f6$var$camera","$c345b227375090f6$var$scene","$c345b227375090f6$var$gui","$c345b227375090f6$var$stats","$c345b227375090f6$var$boxHelper","$c345b227375090f6$var$outputContainer","$c345b227375090f6$var$bvh","$c345b227375090f6$var$geometry","$c345b227375090f6$var$sdfTex","$c345b227375090f6$var$mesh","$c345b227375090f6$var$generateSdfPass","$c345b227375090f6$var$layerPass","$c345b227375090f6$var$raymarchPass","$c345b227375090f6$var$bvhGenerationWorker","$c345b227375090f6$var$inverseBoundsMatrix","$c345b227375090f6$var$rebuildGUI","destroy","$jiuw3","GUI","generationFolder","addFolder","add","displayFolder","onChange","dim","center","quat","Quaternion","scale","boundingBox","getCenter","subVectors","x","y","z","compose","copy","invert","box","dispose","pxWidth","halfWidth","startTime","WebGL3DRenderTarget","texture","format","RedFormat","type","FloatType","minFilter","LinearFilter","magFilter","material","updateFrom","i","setRenderTarget","render","readRenderTargetPixels","Float32Array","Data3DTexture","needsUpdate","posAttr","attributes","position","indexAttr","index","point","normal","delta","tri","Triangle","target","set","applyMatrix4","dist","closestPointToPoint","distance","faceIndex","i0","getX","i1","i2","setFromAttributeAndIndices","getNormal","image","data","dot","innerText","toFixed","getElementById","WebGLRenderer","antialias","setPixelRatio","setSize","innerWidth","innerHeight","setClearColor","outputEncoding","sRGBEncoding","body","Scene","light","DirectionalLight","AmbientLight","PerspectiveCamera","far","updateProjectionMatrix","Box3Helper","Box3","$5Rd1x","OrbitControls","$parcel$interopDefault","$RPVlj","FullScreenQuad","$8todg","GenerateMeshBVHWorker","$7lx9d","GLTFLoader","setMeshoptDecoder","$kp7Te","MeshoptDecoder","loadAsync","then","gltf","scene","updateMatrixWorld","staticGen","StaticGeometryGenerator","useGroups","generate","maxLeafTris","result","Mesh","MeshStandardMaterial","aspect","$c345b227375090f6$var$init","$c345b227375090f6$var$render","requestAnimationFrame","tex","isData3DTexture","gridMode","depth","projectionMatrixInverse","matrixWorld","premultiply","multiply"],"version":3,"file":"sdfGeneration.3e4cbe3a.js.map"}